<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Geetest拖拽验证码破解思路（java）]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FGeetest-Crack.html</url>
    <content type="text"><![CDATA[项目中有个需求希望能获取公司的工商注册信息，刚开始是想与第三方数据公司合作，因种种原因合作没有达成。于是想做个爬虫直接从工商局的《企业信用信息公示系统》中获取。要想从《企业信用信息公示系统》中爬取数据，首先必须解决掉Geetest验证码的问题。经过一系列的摸索，发现要想破解geetest的验证码，主要需要解决如下几个问题：背景图的还原找到背景图中缺口的位置将滑块拖拽到缺口背景图的还原Geetest背景图分为两张，一张是完整背景图，一张是带缺口的背景图。每张图片被分成52 份， 上下两部分各 26 份，然后乱序排列。在网页上显示时，是通过css来将乱序的碎片重新组列成完整的图片。乱序图片： 正常图片：因此，我们必须将原始的背景乱序图片切根据页面上的css样式将图片切割成 52 份，并按照先后顺序拼接还原成正确的图片。需要使用到java.awt.image.BufferedImage类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 将Geetest打乱的图片还原，Geetest的原始背景图是分成52份碎片乱序组合的。目前是上下各26份，每份碎片图片宽10px， 高58px。 * * @param image 原始背景图 * @param locations 展示位置列表，数据结构：[&#123;x=-25, y=-58&#125;, ...] * @return 顺序排列好的图片 */public static BufferedImage recover(BufferedImage image, List&lt;Map&lt;String, Integer&gt;&gt; locations) throws IOException &#123; long begin = System.currentTimeMillis(); int per_image_with = 10; // 每张碎片图片的宽度 int per_image_height = 58; // 每张碎片图片的高度 List&lt;BufferedImage&gt; upperList = new ArrayList&lt;&gt;(); List&lt;BufferedImage&gt; downList = new ArrayList&lt;&gt;(); // 将原始图片裁剪成碎片 for (Map&lt;String, Integer&gt; location : locations) &#123; int x = location.get("x"); int y = location.get("y"); if (y == -58) &#123; upperList.add(image.getSubimage(abs(x), 58, per_image_with, per_image_height)); &#125; else if (y == 0) &#123; downList.add(image.getSubimage(abs(x), 0, per_image_with, per_image_height)); &#125; &#125; BufferedImage newImage = new BufferedImage(upperList.size() * per_image_with, image.getHeight(), image.getType()); // 重绘图片的上半部分 int x_offset = 0; for (BufferedImage bufferedImage : upperList) &#123; Graphics graphics = newImage.getGraphics(); graphics.drawImage(bufferedImage, x_offset, 0, null); x_offset += bufferedImage.getWidth(); &#125; // 重绘图片的下半部分 x_offset = 0; for (BufferedImage bufferedImage : downList) &#123; Graphics graphics = newImage.getGraphics(); graphics.drawImage(bufferedImage, x_offset, 58, null); x_offset += bufferedImage.getWidth(); &#125; log.debug("还原图片耗时：&#123;&#125;ms", System.currentTimeMillis() - begin); return newImage;&#125; 找到背景图中缺口的位置 正常图片：  缺口图片： Geetest验证时，只需要将拼图块水平移动到正确的位置即可。因此通过上面两张图片比对，发现我们只要找到缺口的x坐标即可。 这里我借用的参考内容的方法：两张原始图的大小都是相同的 260*116，那就通过两个for 循环依次对比每个像素点的 RGB 值，如果相差超过 50 则就认为找到了缺口的位置。 12345678910111213141516171819202122232425262728293031323334353637/** * 计算验证图的缺口位置（x轴） 两张原始图的大小都是相同的260*116，那就通过两个for循环依次对比每个像素点的RGB值， 如果RGB三元素中有一个相差超过50则就认为找到了缺口的位置 * * @param image1 图像1 * @param image2 图像2 * @return 缺口的x坐标 */public static int getDiffX(BufferedImage image1, BufferedImage image2) &#123; long begin = System.currentTimeMillis(); for (int x = 0; x &lt; image1.getWidth(); x++) &#123; for (int y = 0; y &lt; image1.getHeight(); y++) &#123; if (!isSimilar(image1, image2, x, y)) &#123; return x; &#125; &#125; &#125; log.debug("图片对比耗时：&#123;&#125;ms", System.currentTimeMillis() - begin); return 0;&#125;/** * 判断image1, image2的[x, y]这一像素是否相似，如果该像素的RGB值相差都在50以内，则认为相似。 * * @param image1 图像1 * @param image2 图像2 * @param x_offset x坐标 * @param y_offset y坐标 * @return 是否相似 */public static boolean isSimilar(BufferedImage image1, BufferedImage image2, int x_offset, int y_offset) &#123; Color pixel1 = new Color(image1.getRGB(x_offset, y_offset)); Color pixel2 = new Color(image2.getRGB(x_offset, y_offset)); return abs(pixel1.getBlue() - pixel2.getBlue()) &lt; 50 &amp;&amp; abs(pixel1.getGreen() - pixel2.getGreen()) &lt; 50 &amp;&amp; abs(pixel1.getRed() - pixel2.getRed()) &lt; 50;&#125; 将滑块拖拽到缺口Geetest在拖拽拼图块时，对拼图块的移动轨迹做了一些 “ 人工智能 ” 的算法识别，使用程序直接将拼图块拖入缺口时，发现有很大的概率会被识别为机器操作，页面显示怪物 吃掉了饼图。因此我们需要采用一些算法来模拟人拖拽的行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/** * 根据缺口位置x_offset，仿照手动拖动滑块时的移动轨迹。 * 手动拖动滑块有几个特点： * 开始时拖动速度快，最后接近目标时会慢下来； * 总时间大概1~3秒； * 有可能会拖超过后再拖回头； * * @return 返回一个轨迹数组，数组中的每个轨迹都是[x,y,z]三元素：x代表横向位移，y代表竖向位移，z代表时间间隔，单位毫秒 */private static List&lt;Map&lt;String, Integer&gt;&gt; getTrack(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks; long begin = System.currentTimeMillis(); // 实际上滑块的起始位置并不是在图像的最左边，而是大概有6个像素的距离，所以滑动距离要减掉这个长度 x_offset = x_offset - 6; if (getRandom(0, 10) % 2 == 0) &#123; tracks = strategics_1(x_offset); &#125; else &#123; tracks = strategics_2(x_offset); &#125; log.debug("生成轨迹耗时: &#123;&#125;ms", System.currentTimeMillis() - begin); log.debug("计算出移动轨迹: &#123;&#125;", tracks); return tracks;&#125;/** * 轨迹策略1 */private static List&lt;Map&lt;String, Integer&gt;&gt; strategics_1(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks = new ArrayList&lt;&gt;(); float totalTime = 0; int x = getRandom(1, 3); // 随机按1~3的步长生成各个点 while (x_offset - x &gt;= 5) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", x); point.put("y", 0); point.put("z", 0); tracks.add(point); x_offset = x_offset - x; x = getRandom(1, 5); totalTime += point.get("z").floatValue(); &#125; // 后面几个点放慢时间 for (int i = 0; i &lt; x_offset; i++) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", 1); point.put("y", 0); point.put("z", getRandom(10, 200)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; log.debug("预计拖拽耗时: &#123;&#125;ms", totalTime); return tracks;&#125;/** * 轨迹策略2 */private static List&lt;Map&lt;String, Integer&gt;&gt; strategics_2(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks = new ArrayList&lt;&gt;(); float totalTime = 0; int dragX = 0; // 已拖拽的横向偏移量 int nearRange = getRandom(5, 10); // 靠近缺口的范围 while (dragX &lt; x_offset - nearRange) &#123; // 生成快速拖拽点，拖拽距离非常靠近切口 int stepLength = getRandom(1, 5); // 随机按1~5的步长生成各个点 Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", stepLength); point.put("y", 0); point.put("z", getRandom(0, 2)); tracks.add(point); totalTime += point.get("z").floatValue(); dragX += stepLength; &#125; // 随机一定的比例将滑块拖拽过头 if (getRandom(0, 99) % 2 == 0) &#123; int stepLength = getRandom(10, 15); // 随机按1~5的步长生成各个点 Map&lt;String, Integer&gt; attachPoint = new HashMap&lt;&gt;(3); attachPoint.put("x", stepLength); attachPoint.put("y", 0); attachPoint.put("z", getRandom(0, 2)); tracks.add(attachPoint); dragX += stepLength; totalTime += attachPoint.get("z").floatValue(); &#125; // 精确点 for (int i = 0; i &lt; Math.abs(dragX - x_offset); i++) &#123; if (dragX &gt; x_offset) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", -1); point.put("y", 0); point.put("z", getRandom(10, 100)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; else &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", 1); point.put("y", 0); point.put("z", getRandom(10, 100)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; &#125; log.debug("预计拖拽耗时: &#123;&#125;ms", totalTime); return tracks;&#125;/** * 根据移动轨迹，模拟拖动极验的验证滑块 */private static boolean simulateDrag(WebDriver webDriver, Site site, List&lt;Map&lt;String, Integer&gt;&gt; tracks) throws InterruptedException &#123; log.debug("开始模拟拖动滑块"); WebElement slider = webDriver.findElement(By.cssSelector(site.getGeetest().getSliderKnob())); log.debug("滑块初始位置: &#123;&#125;", slider.getLocation()); Actions actions = new Actions(webDriver); actions.clickAndHold(slider).perform(); for (Map&lt;String, Integer&gt; point : tracks) &#123; int x = point.get("x") + 22; int y = point.get("y") + 22; actions.moveToElement(slider, x, y).perform(); int z = point.get("z"); TimeUnit.MILLISECONDS.sleep(z); &#125; TimeUnit.MILLISECONDS.sleep(getRandom(100, 200)); // 随机停顿100~200毫秒 actions.release(slider).perform(); TimeUnit.MILLISECONDS.sleep(100); // 等待0.1秒后检查结果 try &#123; // 在5秒之内检查弹出框是否消失，如果消失则说明校验通过；如果没有消失说明校验失败。 new WebDriverWait(webDriver, 5).until((ExpectedCondition&lt;Boolean&gt;) driver -&gt; &#123; try &#123; WebElement popupElement = driver.findElement(By.cssSelector(site.getGeetest().getPopupWrap())); return !popupElement.isDisplayed(); &#125; catch (NoSuchElementException e) &#123; return true; // 元素不存在也返回true &#125; &#125;); return true; &#125; catch (Exception e) &#123; return false; &#125;&#125; 总结解决好上面的三点之后，Geetest验证基本就破解掉了，但是要爬取企业信用信息公示系统中的数据还有一些事情要做。目前工商局有多个地区系统，每个系统的页面解析处理也不一样。某些地区系统甚至还针对访问频次做了控制，你可以通过 IP 代理来解决。 完整的代码示例请参考: https://github.com/aqlu/geetest-crack 运行效果： 本文的参考资料：http://blog.csdn.net/paololiu/article/details/52514504]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>geetest</tag>
        <tag>验证码破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS科学上网]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FMacOs-scientific-Surf-the-Internet.html</url>
    <content type="text"><![CDATA[本文将介绍如何在MacOS上采用VMess协议与墙外VPS通信，其中主要用到了[v2ray]这款开源工具。服务端安装(Centos)因为我选择的VPS的Centos的操作系统，所以此章节主要基于Centos操作系统来描述。安装包下载：wget https://github.com/v2ray/v2ray-core/releases/download/v2.40/v2ray-linux-64.zip解压安装包到/opt目录：unzip v2ray-linux-64.zip -d /opt编写配置文件:12cd /opt/v2ray-v2.40-linux-64vi config.json config.json内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "log" : &#123; // 日志输出配置 "access": "/var/log/v2ray/access.log", "error": "/var/log/v2ray/error.log", "loglevel": "warning" &#125;, // 对外提供 vmess 协议 "inbound": &#123; "port": 28399, // 监听端口 "protocol": "vmess", "settings": &#123; "clients": [&#123; "id": "3b129ddd-72a3-4d28-aeee-028a0fe86e33", // 可以随机生成一个，但必须保证服务端ID与客户端ID必须保持一致 "level": 1, "alterId": 64, "security": "aes-128-gcm" &#125;] &#125; &#125;, "outbound": &#123; "protocol": "freedom", "settings": &#123;&#125; &#125;, "routing": &#123; "strategy": "rules", "settings": &#123; "rules": [&#123; "type": "field", "ip": [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "::1/128", "fc00::/7", "fe80::/10" ], "outboundTag": "blocked" &#125;] &#125; &#125;&#125; 启动v2ray服务：/opt/v2ray-v2.40-linux-64/v2ray -config=/opt/v2ray-v2.40-linux-64/config.json &gt; v2ray.log &amp; 客户端安装(MacOs) 安装包下载：wget https://github.com/v2ray/v2ray-core/releases/download/v2.40/v2ray-macos.zip 解压安装包到/usr/local/opt目录：unzip v2ray-linux-64.zip -d /usr/local/opt 编写配置文件: 12cd /usr/local/opt/v2ray-v2.40-linux-64vi config.json config.json内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; "log" : &#123; "access": "/var/log/v2ray/access.log", "error": "/var/log/v2ray/error.log", "loglevel": "warning" &#125;, // 对外提供 socks5 协议 "inbound": &#123; "port": 1080, // 监听端口 "protocol": "socks", // 入口协议为 SOCKS 5 "settings": &#123; "auth": "noauth" //socks的认证设置，noauth 代表不认证，由于 socks 通常在客户端使用，所以这里不认证 &#125; &#125;, "outbound": &#123; "protocol": "vmess", // 出口协议，对应服务端的入口协议 "settings": &#123; "vnext": [&#123; "address": "serveraddr.com", // 服务器地址，请修改为你自己的服务器 ip 或域名 "port": 28399, // 服务器端口，对应服务器端入口的端口 "users": [&#123; "id": "3b129ddd-72a3-4d28-aeee-028a0fe86e33", // 用户ID, 服务端ID与客户端ID必须保持一致 "alterId": 64 // 此处的值也应当与服务器相同 &#125;] &#125;] &#125; &#125;, "routing": &#123; "strategy": "rules", "settings": &#123; "rules": [&#123; "type": "field", "ip": [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "::1/128", "fc00::/7", "fe80::/10" ], "outboundTag": "blocked" &#125;] &#125; &#125;&#125; 启动v2ray服务：/usr/local/opt/v2ray-v2.40-linux-64/v2ray -config=/usr/local/opt/v2ray-v2.40-linux-64/config.json &gt; v2ray.log &amp; 客户端安装的另一种方式（基于Docker安装） 下载镜像： docker pull v2ray/official 编写配置文件： 123mkdir -p ~/v2raycd ~/v2rayvi config.json # 内容请参考客户端安装(MacOs) 创建容器： 1docker run -d --restart=always --name v2ray -v ~/v2ray:/etc/v2ray -p 1080:1080 v2ray/official v2ray -config=/etc/v2ray/config.json -p 后面跟的端口为config.json中inbound配置的监听端口 校验容器是否创建成功：docker container ls 启动容器：docker start 停止v2ray：docker stop v2ray 重启v2ray：docker restart v2ray 查看日志：docker container log v2ray 更多参考资料 项目：https://github.com/v2ray/v2ray-core 用户手册：https://www.v2ray.com/ 其它文档：https://toutyrater.github.io/]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>vmess</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F%2Fhello-world.html</url>
    <content type="text"><![CDATA[Hello World!这是我的第一篇博客，感谢Hexo提供了一个简单好用的博客框架，感谢NexT优雅的的主题。此博客是本人的一个杂记。为什么叫杂记？其实就是一些乱七八糟的东西，可能是曾经的一些技术笔记，也可能是一些技术专题的连载，也可能是一些生活观点与琐事。]]></content>
  </entry>
</search>
