<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RocketMQ Performance Test]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2FJava%2FRocketMQ-Performance-Test.html</url>
    <content type="text"><![CDATA[测试环境硬件配置4C 4G SSD操作系统centeOS 6.5MQ版本rocketmq-broker-4.2.0-incubating-SNAPSHOT （2017-08-23）测试程序运行机器：Macbook Pro i7 2.3GHz, 16G单Broker场景单broker同步发送（单发送进程），每条message大小：30bytesNameServer与Broker分别在不同机器部署，broker采用异步持久化topic设置： perm: 6 JVM设置： NameServer: -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g 发送条数成功率耗时（s)发送速率（条/秒）备注100000100%74.2651346.52写queue数量：4100000100%75.3471327.22写queue数量：8结论成功率非常有保证，调整topic的queue数量并不能提升发送速率。broker的能力并没有完全被发挥出来，CPU非常闲。单broker异步发送（单发送进程），每条message大小：30bytesNameServer与Broker分别在不同机器部署，broker采用异步持久化topic设置： perm: 6 JVM设置： NameServer： -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g 发送条数成功率耗时（s)发送速率（条/秒）备注1000000100%33.42029922.20写queue数量：4，每发送37条休眠一毫秒，限制生产者速度不超过37000条/秒100000096.6024%20.87146285.46写queue数量：4，发送端不限速1000000100%33.47729871.25写queue数量：8，每发送37条休眠一毫秒，限制生产者速度不超过37000条/秒100000097.9327%22.96148844.23写queue数量：8，发送端不限速结论吞吐量较大时，会触发broker端的流控限制，会导致消息发送失败，出现异常：Rocketmq:MQBrokerException: CODE: 2 DESC: [TIMEOUT_CLEAN_QUEUE]。通过多次反复测试，发现在保证发送成功率100%的情况下，发送速率最大为29922.20条/秒，测试过程中，测试程序最大上传网速达到15.9MB/s。在成功率100%的情况下，吞吐量是同步发送的超20倍。不限速（允许少量失败）的情况下，吞吐量是同步发送的超34倍。在单发送进程场景下，增加topic的queue数量并不能提升生产速率。发现的问题（或BUG）测试发现producer.shutdown()时，并没有完全等待SendCallBack执行完就退出，可能会导致有部分callback无法接收到。因此在在测试程序异步发送完成之后，还需要添加一个线程休眠，确保全部消息全部发送到broker。单broker消费（单消费进程），每条message大小：30bytesNameServer与Broker分别在不同机器部署topic设置： perm: 6 JVM设置： NameServer： -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g consumer设置： consumeThreadMax: 64 pullBatchSize: 32 消费条数成功率耗时（s)消费速率（条/秒）备注3000000100%21.353140495.48读queue数量：83000000100%34.37187282.88读queue数量：4结论RocketMQ的消息消费能力非常高，只要消费端的业务处理足够快。单broker的消费超过7w条每秒，基本上可以说满足大部分的实际业务场景。增加topic的queue数量，能明显提高消费速率。（前提是生产的消息要平均分布在各个queue）从测试环境看，消费高峰每秒下载流量超过31MB，Broker的CPU会占用维持在50%左右，消费过程中CPU的IOWait在某一瞬间会超过20%。单broker消费（双消费进程），每条message大小：30bytesNameServer与Broker分别在不同机器部署topic设置： 读队列数量：4 写队列数量：4 perm: 6 JVM设置： NameServer： -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g consumer设置： consumeThreadMax: 64 pullBatchSize: 32 消费条数成功率耗时（s)消费速率（条/秒）消费进程 11000000100%22.54944347.86消费进程21000000100%21.36046796.76结论增加消费者进程并不能提高整体的消费速度，因为消费者本身就是多线程的模式消费。但可以通过增加消费者进程来提升消费端高可用能力，避免消费端的单点故障。多Master Broker场景双Master Broker 同步发送，每条message大小：30bytes三台主机，一台部署NameServer，另外两台各部署Broker mastertopic设置： perm: 6 JVM设置： NameServer: -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g 发送条数成功率耗时（s)发送速率（条/秒）备注100000100%66.8451495.99每个broker4个queue结论同步发送速率双Master Borker与单broker基本在一个数量级 双Master Broker 异步发送（单发送进程），每条message大小：30bytes三台主机，一台部署NameServer，另外两台各部署Broker mastertopic设置： perm: 6 JVM设置： NameServer: -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g Broker设置： 为提高成功率，将waitTimeMillsInSendQueue的默认值从200调整到1000 发送条数成功率耗时（s)发送速率（条/秒）备注1000000100%20.86247934.04每个broker各4个queue， 每发送70条休眠1毫秒，确保每秒发送数量不超过7w条1000000100%20.61648506.01每个broker各8个queue， 每发送70条休眠1毫秒，确保每秒发送数量不超过7w条100000099.7571%16.02662247.03每个broker各4个queue，生产者不限速100000099.8807%17.10858,382.45每个broker各8个queue，生产者不限速结论在保证成功率100%的情况下，双master broker比单broker的发送速率明显提高，提升超60%。增加topic的queue数量，但发送进程并不能提高发送速率双broker消费（单消费进程），每条message大小：30bytes三台主机，一台部署NameServer，另外两台各部署Broker mastertopic设置： perm: 6 JVM设置： NameServer： -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g consumer设置： consumeThreadMax: 64 pullBatchSize: 32 消费条数成功率耗时（s)消费速率（条/秒）备注2000000100%11.170179051.02读queue数量：43000000100%11.979250438.26读queue数量：8结论由于topic在每个broker上都有4个queue，发送的消息基本是均匀分配在两个broker的，因此在消费时能从两个broker分别进行消费，消费速率较单broker的消费提升了近1倍。增大topic的queue数量，明显能提高消费速率。双Master双Slave异步复制，异步发送，每条message大小：30bytes五台主机，一台部署NameServer，两台分别部署broker-a-master、broker-a-slave，两台分别部署broker-b-master、broker-b-slave。topic设置： perm: 6 JVM设置： NameServer: -Xms1g -Xmx1g -Xmn512m Broker: -Xms2g -Xmx2g -Xmn1g Broker设置： master broker设置: brokerRole=ASYNC_MASTER 发送条数成功率耗时（s)发送速率（条/秒）备注100000100%20.75548181.16每个broker各8个queue，每发送70条休眠1毫秒，确保每秒发送数量不超过7w条结论Master与Slave采用异步复制时，基本不影响消息发送的吞吐量。发送100w条消息到broker后（平均分配到broker-a与broker-b），关掉broker-b-master，启动消费者时，如果订阅组之前不存在，则不能从broker-b-slave上进行消费。如果订阅组存在，则能从broker-b-slave上进行消费，但当broker-b-master恢复之后，会重复消费broker-b-master上的消息。发现的问题（或BUG）在slave上进行消费时，消费的offset近保存到了slave上，当master恢复时，slave上的消费offset并没有被同步到master上，master上的offset还是最初在master上的消费位置，因此会导致master故障期间从slave上消费的消息会被重复消费。这应该不是RocketMQ的设计初衷，感觉像是个bug。RocketMQ vs KafkaRocketMQ与Kafka一样，都没有JMS中定义的Queue的存在，只有Topic的存在。但他们都可以基于Topic来实现Queue的功能与特性。RocketMQ可以创建只有1个queue的topic，再结合Cluster的消费方式来实现JMS queue的功能与特性。Kafka则可以创建只有一个partition的topic来实现JMS Queue的功能与特性。RocketMQ中queue的概念可类比为Kafka中的partition，若要实现消息的强顺序消费，RocketMQ需要设置topic只有一个queue，Kafka则需要设置topic只有一个partition。若业务规定只需保证同一订单编号的状态变更的顺序性，RocketMQ可以在发送时通过订单编号与MessageQueueSelector来实现同一编号的订单消息放置在topic的同一个queue中，Kafka则可以将订单编号作为消息的key来确保同一编号的订单消息放置在了同一个partition。table th:nth-of-type(5){width:200px}]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构简介]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2FJava%2FJava-Memory-Model.html</url>
    <content type="text"><![CDATA[Java运行时内存结构12345678910111213+-------------------------------------------------+| Runtime Memory Structure Chart || +--------------+ | +----------+ +----------+ || | | | | | | Native | || | MethodArea | | | VM Stack | | Method | || | (PermGen) | | | | | Stack | || +--------------+ | +----------+ +----------+ || +--------------+ | +------------------------+ || | | | | | || | Heap | | | Program Counter | || | | | | Register | || +--------------+ +------------------------+ |+-------------------------------------------------+ 线程共享数据区域 Heap: 堆，是JVM最大的内存区。 Method Area(PermGen): 方法区，存储类、常量、静态变量等数据。在某些JVM的实现中也称持久代、永久代。 JDK8之后，PermGen被元空间（MetaSpace）替代 线程之间相互独立区域 VM Stack: 虚拟机栈 Native Method Stack: 本地方法栈 Program Counter Register: 程序计数器 通过一张图来了解如何通过参数来控制各区域的内存大小: 堆（Heap）对于大多数应用来说，java堆（Heap）是JVM管理的最大一块内存。Java堆是被所有线程共享的一块内存，在虚拟机启动时创建，主要用来存放对象实例。 堆也是垃圾收集器管理的主要区域，从内存回收的角度看，大部分收集器采用分代回收，所以Java的堆可以细分为：新生代、老生代。新生代可以分为Eden空间、From空间、To空间。 如果堆中没有内存完成实例分配，并且也无法扩展时将会抛出OutOfMemoryError异常。 123456789101112131415161718+----------------------------------------+| Heap Structure || +--------------------+ +-------------+ || | Young Generation | | | || | +----------------+ | | | || | | Eden | | | | || | | Space | | | | || | +----------------+ | | | || | +----------------+ | | Old/Tenured | || | | FromSpace | | | Generation | || | | (Survivor1) | | | | || | +----------------+ | | | || | +----------------+ | | | || | | ToSpace | | | | || | | (Survivor2) | | | | || | +----------------+ | | | || +--------------------+ +-------------+ |+----------------------------------------+ 新生代(Young Generation) Eden Space From Space(Survivor1) To Space(Survivor2) 老生代(Old Generation) 相关参数设置： 参数名 描述 默认值 备注 -Xms 堆的初始值，设置示例：-Xms10m 如果没有设置此值，默认值=分配的新生代值+分配的老生代的值。设置的值必须是1KB的倍数，且最小为1MB。等同于-XX:InitialHeapSize。 -Xmx 堆的最大值，设置示例：-Xmx1g 根据运行时系统配置选择。 等同于-XX:MaxHeapSize。设置的值必须是1KB的倍数，且最小为2MB。在最为服务器模式运行时，一般都设置-Xms等于-Xmx。 -Xmn 新生代的最大值，设置示例：-Xmn10m 建议设置新生代的大小为整个堆大小的：1/4至1/2之间。等同于-XX:MaxNewSize。 -XX:NewSize 新生代的初始值 -XX:SurvivorRation 用于设置Eden和其中一个Survivor的比值 默认值为8，表示80%的为Eden，两个Survivor各占10% -XX:MaxTenuringThreshold 对象在新生代存活周期的阈值 在并行收集器中默认为15，CMS收集器中默认为6 最大值15 -XX:+PrintTenuringDistribution 用于在Minor GC时打印Survivor中各个年龄段对象的占用空间大小 -XX:NewRatio 用于设置老生代和新生代的比例 默认为2，即1/3为新生代，2/3为老生代 参数命名有些奇怪，实际计算公式: 比例值=老生代大小/新生代大小 新生代（Young Generation）用来存放新的对象实例，垃圾收集器会频繁的在此区域工作，当新生代的Eden区满了之后，会触发Minor GC或Young GC。因此新生代设置过小会导致频繁的Minor GC或Young GC。如果设置过大，则只会在Full GC时才被执行，这会消耗较长的时间。 为了优化GC的性能，把新生代又细分成了Eden、Survivor1(from)、Survivor2(to)三个区域。 Eden存储新生的对象。一般新创建的对象都会被分配到Eden区中，某些对象会特殊处理。默认Eden占新生代80%的大小。 Eden区满了之后会触发Minor GC。 Survivor新生代中有两个Survivor区，一个标记为From，一个标记为TO，在GC开始时，被标记为TO的空间一定是空的。 在Minor GC或Young GC发生时，Eden区中没有被引用（ref）的对象将被清除，需要存活的对象都会被复制到一个标记为TO的Survivor区中，From区中需要继续存活的对象会根据存活周期来决定去向，如果超过存活的周期来会被移动到老生代中，反之也会被复制到标记为TO的Survivor区中，如果TO被填满，则TO中所有的对象都会被移动到老生代中。GC完成之后，每个对象的生命周期年龄都会被加1，Eden和From都被清空，FROM和TO也会互换角色，上一次的TO变成新的FROM，新的TO又将是一个空的区域。 老生代（Old Generation）存放生命周期长的对象。也称为“老年代”。对老生代的垃圾回收称为Old GC，当老生代满了之后会触发此GC。 注意 Old GC并不等同于Major GC或Full GC，根据不同的GC的实现，它们所指的范围都不一样。 方法区（MethodArea/Perm Genration）方法区称作“非堆（Non-Heap）”，用来存放类对象、常量、静态变量、即时编译后的代码数据。与Heap一样都属于线程共享。 在习惯在HotSpot虚拟机上开发和部署的程序员来说，很多人把它称为“永久代（Permanent Generation）”，平常所说的永久代也是指这个区域。 尽管这个区域被称为永久代，但有些垃圾收集器也会在此区域执行回收，这个区域的回收主要是常量池的回收、以及类型的卸载。JVM规范没对此区域的限制非常宽松，允许不对此区域实现垃圾收集。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError: PermGen异常。 此空间的调整参数： 参数名 描述 默认值 备注 -XX:PermSize 永久代内存初始值 物理内存的1/64，例如：2G内存的机器初始值为32M -XX:MaxPermSize 永久代内存最大值 物理内存的1/4，例如：2G内存的机器初始值为512M 元空间（MetaSpace）JDK8开始，PermGen被元空间（MetaSpace）替代, PermGen被移除。 其实移除PermGen的工作从JDK7就开始了，但并没有完全移除，譬如类的静态变量、字面量（interned strings）都转移到了java heap中，符号引用转移到了native heap。 元空间的本质与PermGen类似，都是对JVM规范中方法区的实现。最大区别是元空间并不在虚拟机中，而是使用本地内存，因此元空间的大小受本地内存限制。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError: PermGen异常。 元空间的大小是JVM根据垃圾收集的结果来自动调整的。也可以通过如下参数来调整： 参数名 描述 默认值 备注 -XX:MetaspaceSize 元空间初始值 在默认情况下，这个值大小根据不同的平台在12M到20M浮动 该值越大触发Metaspace GC的时机就越晚，达到该值就会触发垃圾收集进行类型卸载。同时垃圾收集器会对该值进行调整：如果释放了大量空间，就会适当降低该值。如果释放了很少的空间，在不超过MaxMetaspaceSize的时，会适当提高该值。受本机最大可用内存限制，受32位与64位的JVM、操作系统限制 -XX:MaxMetaspaceSize 元空间最大值 无限制 超过最大值时，将抛出OutOfMemoryError: PermGen异常。 -XX:MinMetaspaceFreeRatio 元空间最小空闲占比 NA 当进行过元空间GC之后，如果当前元空间的空闲占比小于此值，则增长元空间的大小。此参数可以控制元空间的增长速度，如果该值过小会导致元空间的增长缓慢，可能会影响之后的类加载，如果该值过大会导致元空间增长过快，浪费内存。本机测试效果来看默认值在40左右，也就是40% -XX:MaxMetaspaceFreeRatio 元空间最大空闲占比 NA 当进行过元空间GC之后，如果当前元空间的空闲占比超过此值，则会释放部分元空间。本机测试效果来看默认值在70左右，也就是70% -XX:MinMetaspaceExpansion 元空间增长时的最小幅度 NA 在本机上该参数的默认值为340784B（大约330KB为） -XX:MaxMetaspaceExpansion 元空间增长时的最大幅度 NA 在本机上该参数的默认值为5452592B（大约为5MB） 为什么要将PermGen切换为Metaspace? 字符串存在永久代中，容易出现性能问题和内存溢出。 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老生代溢出。 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。 Oracle 可能会将HotSpot 与 JRockit 合二为一。 程序计数器（Program Counter）程序计数器也被称为“PC寄存器”。JVM支持多线程同时运行，每个线程都有自己独立且私有的程序计数器，占用空间极少，在线程创建时创建。 解释器通过它来获取下一条的字节码执行指令。如果执行的是java的方法，该程序计数器中保存的是当前执行指令的地址，如果是native方法，则该程序计数器中的值为undefined。 不会有OutOfMemoryError抛出。 栈（Stack）虚拟机栈（VM Stack）虚拟机栈所使用的空间也是线程私有的，以栈帧为单位进行压栈和出栈。 123456789101112131415161718192021222324252627282930313233343536 当前线程 线程2 线程n+-----------------------------+ +------+ +------+| 当前栈帧 | | | | || Current Stack Frame | | | | |+-----------------------------+ | | | || +-------------------------+ | | | | || | 局部变量 | | | | | || | Local Variable Table | | | | | || +-------------------------+ | | | | || +-------------------------+ | | | | || | 操作数栈 | | | | | || | Operand Stack | | | | | || +-------------------------+ | | | | || +-------------------------+ | | | | || | 动态连接 | | | | | || | Dynamic Linking | | | | | || +-------------------------+ | | | | || +-------------------------+ | | | | || | 返回地址 | | | | | || | Return Address | | | | ...... | || +-------------------------+ | | | | || +-------------------------+ | | | | || | 附加信息 | | | | | || | Additional Info | | | | | || +-------------------------+ | | | | || ...... | | | | |+-----------------------------+ | | | || | | | | || Stack Frame n | | | | |+-----------------------------+ | | | || | | | | || Stack Frame 2 | | | | |+-----------------------------+ | | | || | | | | || Stack Frame 1 | | | | |+-----------------------------+ +------+ +------+ 局部变量表 每一个方法都拥有一块属于自己的内存区域来保存方法内部定义的局部变量，这块区域就是局部变量表，当这个方法运行结束后，这个局部变量的生命周期也就宣告结束。我们平常工作中所指的栈，实际上指的是虚拟机栈中的栈帧中的局部变量表。 操作数栈 每个方法的内部都可以计算数据，而计算数据势必需要拥有一块内存区域，为虚拟机用来进行数值计算。因此在栈帧中，就需要有一块区域专门为当前方法计算数据使用，它就是操作数栈。 在每进行一次完整的计算之后，栈中的数据都已经出栈，所以操作数栈的空间在一个方法内部是可以反复使用的。所以虚拟机在分配内存大小时，只分配当前方法，单次完整计算所需要的最大内存空间给当前栈帧，以减少内存的消耗。 同时为了增加运行效率，减少数据的不断复制，在大部分虚拟机的实现中，将当前方法的局部变量表和上层方法的操作数栈的内存形成部分重叠，从而减少参数的不断复制而引起的性能消费。 动态连接 虚拟机在执行方法时有两种形式被用来确定执行指令所对应的方法，第一种是类加载时，可以直接确定要执行的方法，譬如静态方法，私有方法，final方法等。这种形式叫做静态解析。第二种是在真正运行时，根据对象的真实引用来判断当前真正要执行的方法，这种形式称之为动态连接。 在字节码文件中，都存在一个常量池，在这个常量池中保存有大量的符号引用，这个符号引用是每一个方法的间接引用。在字节码指令的中，使用的是这个符号引用。但是在运行时阶段，肯定需要调用到要执行方法在内存中真实的地址。这就需要将间接引用转化成直接引用。而这里的“动态连接”就是为了保证在运行时阶段，方法可以正确的找到要调用的方法，每个栈帧将自己在运行时常量池中所对应的真实地址记录的位置。 这里需要注意的是，在栈帧中的动态连接和查找符号引用为真实引用中的动态连接，是两个概念。前者表示的是一个区域，后者表示的是一种查找方式。 返回地址 退出当前方法的方式有两种，第一种是遇到返回指令时，正常的退出当前方法。另一种形式是遇到没有捕获而被抛出的异常。无论何种返回形式，在方法退出后，栈帧的顶端都应是当前退出方法的上层方法。同时上层方法的执行状态也需要根据当前的返回结果重新调整。所以每个栈帧可以利用“返回地址”这块区域帮助上层方法恢复状态。 附加信息 对于虚拟机规范中没有申明的，拥有指定存放位置的信息可以由各个虚拟机自己决定，放置到这个区域中。 有两种可能的异常抛出：StackOverflowError、OutOfMemoryError。StackOverflowError指的是内存中的栈结构在不断的入栈，最终导致栈的深度超过了虚拟机所允许的栈深度时，所抛出的错误 相关参数设置： 参数名 描述 默认值 备注 -Xss 线程栈大小，设置示例：-Xss320k 不同的平台默认值不同。32位环境一般为320kb，64位环境一般为1024kb。 此参数等同于XX:ThreadStackSize 本地方法栈（Native Method Stack）在虚拟机中，不但运行java方法，还会运行本地方法，也就是常见的native关键字修饰的方法。本地方法运行所使用的空间就是本地方法栈，其也是线程私有的。 它的作用跟虚拟机栈基本相似，其区别就是一个为java方法服务，一个为Native发光法服务。在虚拟机规范中，对于本地方法栈中的结构、方法的语言、方式，都没有强制规定，各个虚拟机可以自由的实现它。 直接内存（Direct Memory）这块内存不属于运行时数据区，所以不受JVM堆大小的限制。 从Jdk1.4开始，NIO（new I/O）变可以直接使用Native函数直接分配这块内存。使用Java堆中的DirectByteBuffer对象作为这块内存的引用。 在使用NIO的应用中，配置虚拟机参数需要考虑到这块内存的大小分配，申请不到内存时也会抛出OutOfMemoryError。 相关参数设置： 参数名 描述 默认值 备注 -XX:MaxDirectMemorySize 最大直接内存值，设置示例：-XX:MaxDirectMemorySize=10m 默认情况下，大小设置为0，这意味着JVM将自动分配和扩展。 关于GC针对HotSpot VM的实现，GC的分类只有两大种： Partial GC: 局部GC Young GC: 只收集新生代 Old GC: 只收集老生代，只有CMS的concurrent collection是这个模式 Mixed GC: 收集所有新生代以及部分老生代。只有G1才有此模式。 Full GC: 全量GC，收集整个堆(包括新生代和老生代)、以及方法区（java8之前的PermGen, java8开始的metaspace）。 通常所说的Major GC与Full GC是等价的。但由于HotSpot VM发展了这么多年，很对名词解读已经混乱，当有人说Major GC时，一点要问清楚他说的是Full GC还是Old GC。 对于HotSpot VM的串行收集器（Serial GC）的实现来看，各GC场景的触发条件是： Young GC: Eden区没有足够空间进行分配时触发； Old GC: 老生代没有足够空间进行分配时触发；只有CMS的concurrent collection是这个模式 Full GC: 方法区PermGen或Metaspace没有足够空间进行分配时触发 在准备触发Young GC时，如果发现之前Young GC移动到老生代的平均大小大于当前老生代剩余空间时，会取消Young GC转而触发Full GC (除CMS的concurrent collection之外，其它的针对老生代的回收一般都会包含对新生代的处理) 程序调用System.gc() 堆HeapDump时带GC，默认也会触发 对于HotSpot VM的并行收集器（Parallel GC）的实现则不一样，以CMS为例，它会定时去检查老生代的是用量，超过一定的比例就会触发。 相关测试代码堆（Heap）内存溢出测试代码1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;/** * 堆（Heap）内存溢出测试代码 * 启动时添加如下参数可以观察GC日志： * -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:-UseCompressedClassPointers * 添加如下参数设置JVM堆大小： * -Xms16m -Xmn8m -Xmx16m */public class HeapTest &#123; public static void main(String[] args) &#123; List&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;(); int i = 0; boolean flag = true; while (flag)&#123; try &#123; i++; list.add(new byte[1024 * 1024]);//每次增加一个1M大小的数组对象 &#125;catch (Throwable e)&#123; e.printStackTrace(); flag = false; System.out.println("count=" + i);//记录运行的次数 &#125; &#125; &#125; 方法区（PermGen/Metaspace）内存溢出测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import jdk.internal.org.objectweb.asm.ClassWriter;import jdk.internal.org.objectweb.asm.MethodVisitor;import jdk.internal.org.objectweb.asm.Opcodes;import java.util.ArrayList;import java.util.List;/** * 方法区（PermGen/Metaspace）内存溢出测试代码 * 启动时添加如下参数可以观察GC日志： * -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:-UseCompressedClassPointers */public class MetaspaceTest extends ClassLoader &#123; public static void main(String[] args) &#123; // 类持有 List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(); // 死循环不断的生成不同的类。 for (int i = 1; i &gt; 0; i++) &#123; ClassWriter cw = new ClassWriter(0); // 定义一个类名称为Class&#123;i&#125;，它的访问域为public，父类为java.lang.Object，不实现任何接口 cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, "Class" + i, null, "java/lang/Object", null); // 定义构造函数&lt;init&gt;方法 MethodVisitor mw = cw.visitMethod(Opcodes.ACC_PUBLIC, "&lt;init&gt;", "()V", null, null); // 第一个指令为加载this mw.visitVarInsn(Opcodes.ALOAD, 0); // 第二个指令为调用父类Object的构造函数 mw.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "&lt;init&gt;", "()V", false); // 第三条指令为return mw.visitInsn(Opcodes.RETURN); mw.visitMaxs(1, 1); mw.visitEnd(); MetaspaceTest test = new MetaspaceTest(); byte[] code = cw.toByteArray(); // 定义类 Class&lt;?&gt; exampleClass = test.defineClass("Class" + i, code, 0, code.length); classes.add(exampleClass); &#125; &#125;&#125; 虚拟机栈（VM Stack）溢出测试源码12345678910111213141516171819202122/** * 虚拟机栈（VM Stack）溢出测试源码 * 本机测试大概在栈深度达到22217时会出现溢出，每次运行值存在一定偏差 */public class StackTest &#123; private static int index = 1; public void call()&#123; index++; call(); &#125; public static void main(String[] args) &#123; StackTest mock = new StackTest(); try &#123; mock.call(); &#125;catch (Throwable e)&#123; System.out.println("Stack deep : " + index); e.printStackTrace(); &#125; &#125;&#125; 字符串常量溢出测试源码123456789101112131415161718/** * 字符串常量溢出测试源码. * jvm 6中运行会抛出`OutOfMemoryError: PermGen space` * jvm 7和jvm 8中运行会抛出`OutOfMemoryError: Java heap space` */public class StringTest &#123; static String static_str = "xxxxxx"; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 以2的指数级不断的生成新的字符串 while(true)&#123; String str = static_str + static_str; base = static_str; list.add(str.intern()); &#125; &#125;&#125; 参考资料 https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html http://www.importnew.com/23746.html http://blog.csdn.net/xlnjulp/article/details/46763045 https://dzone.com/articles/java-8-permgen-metaspace http://caoyaojun1988-163-com.iteye.com/blog/1969853 http://www.cnblogs.com/smyhvae/p/4748392.html]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hystrix 配置属性参考]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2FJava%2FHystrix-configuration.html</url>
    <content type="text"><![CDATA[介绍Hystrix使用Archaius作为配置属性的默认实现。下面的文档描述了默认使用的HystrixPropertiesStrategy实现，你也可以使用插件的方式来覆盖它。每个属性有四个优先级：代码的全局默认值如果没有设置以下3个，则这是默认值。 全局默认值在下表中显示为 “默认值”。动态全局默认属性你可以使用属性更改全局默认值。 全局默认属性名称在下表中显示为 “默认属性”。用代码定义默认实例属性你可以定义特定于实例的默认值。例：1HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(int value) 你需要类似于以下的方式将这种命令插入到HystrixCommand构造函数中： 12345public HystrixCommandInstance(int id) &#123; super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ExampleGroup")) .andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(500))); this.id = id;&#125; 一般的设置初始值可以采用便利的构造函数方式。这是一个例子： 1234public HystrixCommandInstance(int id) &#123; super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"), 500); this.id = id;&#125; 动态设置实例属性 你可以动态设置实例特定的值，从而覆盖前面三个默认级别。 动态实例属性名称在下表中显示为 “实例属性”。 例： 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutInMilliseconds 将属性的HystrixCommandKey部分替换为您所定位的HystrixCommand的HystrixCommandKey.name())值。 例如，如果被命名为“SubscriberGetAccount”，则属性名称将是： hystrix.command.SubscriberGetAccount.execution.isolation.thread.timeoutInMilliseconds 命令属性（Command Properties）以下属性将控制HystrixCommand的行为： 执行（Execution）以下属性控制HystrixCommand.run())执行。 execution.isolation.strategy这个属性指示HystrixCommand.run()执行的隔离策略，有以下两种选择之一： THREAD —— 它在单独的线程上执行，并发请求受线程池中线程数量的限制 SEMAPHORE —— 它在调用线程上执行，并发请求受信号计数的限制 线程或信号量 缺省值和建议的设置是运行HystrixCommand时使用线程隔离（THREAD），和运行HystrixObservableCommand时使用信号隔离（SEMAPHORE）。 在线程中执行命令能对网络超时提供另一层保护。 通常情况下，对于HystrixCommand来说，唯一使用信号量隔离的场景是，当调用量非常大（每秒数百次）时单独线程的开销太高；这通常只适用于非网络调用。 Netflix的API在40+线程池中运行100+命令，并且只有少数命令不在线程中运行 —— 那些从内存中的缓存提取元数据或或是门面到线程隔离命令（更多信息请参见Primary + Secondary with Fallback” pattern）。 更多信息请参见隔离是如何工作的。 默认值 THREAD（参见：ExecutionIsolationStrategy.THREAD） 取值范围 THREAD, SEMAPHORE 默认属性 hystrix.command.default.execution.isolation.strategy 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.strategy 如何设置默认实例 // to use thread isolation HystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD) // to use semaphore isolation HystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE) execution.isolation.thread.timeoutInMilliseconds该属性设置以毫秒为单位，在该时间之后，调用者将观察到超时并离开命令执行。 Hystrix将HystrixCommand标记为TIMEOUT，并执行回退逻辑。请注意，如果需要可以为每个命令配置关闭超时的设置（请参阅command.timeout.enabled）。 注意： 超时将在HystrixCommand.queue()上触发，即使调用者从未在生成的Future上调用get()。在Hystrix 1.4.0之前，只有调用get()才能使超时机制在这种情况下生效。 默认值 1000 默认属性 hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(int value) execution.timeout.enabled该属性指示HystrixCommand.run()执行是否应该有一个超时。 默认值 true 默认属性 hystrix.command.default.execution.timeout.enabled 实例属性 hystrix.command.HystrixCommandKey.execution.timeout.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionTimeoutEnabled(boolean value) execution.isolation.thread.interruptOnTimeout这个属性指示HystrixCommand.run()执行是否应该在发生超时时被中断。 默认值 true 默认属性 hystrix.command.default.execution.isolation.thread.interruptOnTimeout 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnTimeout 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionIsolationThreadInterruptOnTimeout(boolean value) execution.isolation.thread.interruptOnCancel这个属性指示HystrixCommand.run()执行是否应该在发生取消时被中断。 默认值 false 默认属性 hystrix.command.default.execution.isolation.thread.interruptOnCancel 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnCancel 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionIsolationThreadInterruptOnCancel(boolean value) execution.isolation.semaphore.maxConcurrentRequests当您使用ExecutionIsolationStrategy.SEMAPHORE时，此属性设置允许HystrixCommand.run()方法的最大请求数。 如果达到这个最大并发限制，则后续请求将被拒绝。 当你选择一个信号量时，你使用的逻辑基本上和你选择线程池中添加多少个线程相同，但是信号量的开销要小得多，通常执行速度要快得多（亚毫秒） ，否则你会使用线程。 例如，5000rps的单个实例在内存中查找指标聚集仅需要2个信号量就能工作。 隔离原理仍然是相同的，所以信号量应该仍然是整个容器（如：Tomcat）线程池的一小部分，而不是全部或大部分，否则它不提供保护。 默认值 10 默认属性 hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.semaphore.maxConcurrentRequests 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionIsolationSemaphoreMaxConcurrentRequests(int value) 回退（Fallback）以下属性控制HystrixCommand.getFallback()如何执行。这些属性适用于ExecutionIsolationStrategy.THREAD和ExecutionIsolationStrategy.SEMAPHORE。 fallback.isolation.semaphore.maxConcurrentRequests该属性设置HystrixCommand.getFallback()方法允许从调用线程中创建的最大请求数。 如果达到最大并发限制，则随后的请求将被拒绝并抛出异常，因为没有回退被提取到。 默认值 10 默认属性 hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests 实例属性 hystrix.command.HystrixCommandKey.fallback.isolation.semaphore.maxConcurrentRequests 如何设置默认实例 HystrixCommandProperties.Setter().withFallbackIsolationSemaphoreMaxConcurrentRequests(int value) fallback.enabledSince: 1.2 该属性设置是否在发生故障或拒绝时尝试调用HystrixCommand.getFallback()。 默认值 true 默认属性 hystrix.command.default.fallback.enabled 实例属性 hystrix.command.HystrixCommandKey.fallback.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withFallbackEnabled(boolean value) 断路器（Circuit Breaker）断路器属性控制HystrixCircuitBreaker的行为。 circuitBreaker.enabled该属性设置是否将使用断路器来跟踪健康状况并且如果断路器跳闸则将其短路。 默认值 true 默认属性 hystrix.command.default.circuitBreaker.enabled 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerEnabled(boolean value) circuitBreaker.requestVolumeThreshold该属性设置滚动窗口中将使电路跳闸的最小请求数量。 例如，如果值是20，那么如果在滚动窗口中接收到19个请求（例如10秒的窗口），则即使所有19个请求都失败，电路也不会跳闸。 默认值 20 默认属性 hystrix.command.default.circuitBreaker.requestVolumeThreshold 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.requestVolumeThreshold 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerRequestVolumeThreshold(int value) circuitBreaker.sleepWindowInMilliseconds该属性设置跳闸后的时间量，拒绝请求，然后再次尝试确定电路是否应再次闭合。 默认值 5000 默认属性 hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.sleepWindowInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerSleepWindowInMilliseconds(int value) circuitBreaker.errorThresholdPercentage该属性设置错误百分比，在该值以上，电路应断开并开始将请求短路到回退逻辑。 默认值 50 默认属性 hystrix.command.default.circuitBreaker.errorThresholdPercentage 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.errorThresholdPercentage 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerErrorThresholdPercentage(int value) circuitBreaker.forceOpen如果该属性为真，则强制断路器进入打开（跳闸）状态，将拒绝所有的请求。 此属性优先于circuitBreaker.forceClosed。 默认值 false 默认属性 hystrix.command.default.circuitBreaker.forceOpen 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.forceOpen 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerForceOpen(boolean value) circuitBreaker.forceClosed如果该属性为真，则强制断路器进入关闭状态，在该状态下将允许请求，而不管错误百分比如何。 circuitBreaker.forceOpen属性优先，所以如果它被设置为true，这个属性什么都不做。 默认值 false 默认属性 hystrix.command.default.circuitBreaker.forceClosed 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.forceClosed 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerForceClosed(boolean value) 度量（Mitrics）以下属性与从HystrixCommand和HystrixObservableCommand执行捕获指标有关。 metrics.rollingStats.timeInMilliseconds该属性设置统计滚动窗口的持续时间，以毫秒为单位。这是Hystrix保持断路器使用和发布指标的时间。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 窗口根据这些增量被分成桶和“卷”。 例如，如果将此属性设置为10秒（10000），具有十个1秒桶的，则下图显示了如何将新桶和旧桶关闭： 默认值 10000 默认属性 hystrix.command.default.metrics.rollingStats.timeInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingStats.timeInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingStatisticalWindowInMilliseconds(int value) metrics.rollingStats.numBuckets该属性设置滚动统计窗口分成的桶的数量。 注意： 必须要确保如下条件： “metrics.rollingStats.timeInMilliseconds ％ metrics.rollingStats.numBuckets == 0” ， 否则会引发异常。 换句话说，10000/10是可以的，10000/20也行，但是10000/7不行。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 10 取值范围 可以被metric.rollingStats.timeInMilliseconds整除的任何值。结果应该是数百或数千毫秒的桶。大容量的性能还没有测试过小于100ms的桶。 默认属性 hystrix.command.default.metrics.rollingStats.numBuckets 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingStats.numBuckets 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingStatisticalWindowBuckets(int value) metrics.rollingPercentile.enabled这个属性表示执行延迟是否应该跟踪和计算为百分比。如果他们被禁用，则所有汇总统计（平均值，百分位数）返回为-1。 默认值 true 默认属性 hystrix.command.default.metrics.rollingPercentile.enabled 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileEnabled(boolean value) metrics.rollingPercentile.timeInMilliseconds此属性设置滚动窗口的持续时间，在该窗口中保留执行时间以允许百分数计算（以毫秒为单位）。 窗口根据这些增量被分成桶和“卷”。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 6000 默认属性 hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.timeInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileWindowInMilliseconds(int value) metrics.rollingPercentile.numBuckets这个属性设置了rollingPercentile窗口将被分成的桶的数量。 注意： 必须要确保如下条件：“metrics.rollingPercentile.timeInMilliseconds ％ metrics.rollingPercentile.numBuckets == 0” ，否则会引发异常。 换句话说，60000/6是可以的，60000/60也是可以的，但10000/7不行。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 6 取值范围 可以被metric.rollingPercentile.timeInMilliseconds整除的任何值。结果应该是数千毫秒的桶。大容量的性能还没有测试过小于1000ms的桶。 默认属性 hystrix.command.default.metrics.rollingPercentile.numBuckets 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.numBuckets 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileWindowBuckets(int value) metrics.rollingPercentile.bucketSize该属性设置每个桶的最大执行次数。如果更多的执行在此期间发生，他们将环绕并开始在桶的开头重写。 例如，如果桶大小设置为100，并桶的窗口为10秒，但是在此期间发生500次执行，则只有最后100次执行将保留在该10秒的桶中。 如果增加这个大小，这也增加了存储值所需的内存量，并增加了对列表进行排序以进行百分比计算所需的时间。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 100 默认属性 hystrix.command.default.metrics.rollingPercentile.bucketSize 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.bucketSize 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileBucketSize(int value) metrics.healthSnapshot.intervalInMilliseconds此属性设置允许执行运行成功和错误百分比并影响断路器状态的健康快照之间等待的时间（以毫秒为单位）。 在大容量的电路上，连续计算误差百分比可能会成为CPU密集型的，因此这个属性允许你控制计算的频率。 默认值 500 默认属性 hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.metrics.healthSnapshot.intervalInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsHealthSnapshotIntervalInMilliseconds(int value) 请求上下文（Request Context）这些属性涉及HystrixCommand使用HystrixRequestContext功能。 requestCache.enabled此属性指示HystrixCommand.getCacheKey())是否应与HystrixRequestCache一起使用，以通过请求范围缓存提供重复数据删除功能。 默认值 true 默认属性 hystrix.command.default.requestCache.enabled 实例属性 hystrix.command.HystrixCommandKey.requestCache.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withRequestCacheEnabled(boolean value) requestLog.enabled此属性指示是否应将HystrixCommand执行和事件记录到HystrixRequestLog 默认值 true 默认属性 hystrix.command.default.requestLog.enabled 实例属性 hystrix.command.HystrixCommandKey.requestLog.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withRequestLogEnabled(boolean value) 破裂器属性（Collapser Properties）以下属性控制HystrixCollapser行为。 maxRequestsInBatch此属性设置批处理允许的最大请求数量，然后触发批处理执行。 默认值 Integer.MAX_VALUE 默认属性 hystrix.collapser.default.maxRequestsInBatch 实例属性 hystrix.collapser.HystrixCollapserKey.maxRequestsInBatch 如何设置默认实例 HystrixCollapserProperties.Setter().withMaxRequestsInBatch(int value) timerDelayInMilliseconds此属性设置触发执行之后创建批处理的毫秒数。 默认值 10 默认属性 hystrix.collapser.default.timerDelayInMilliseconds 实例属性 hystrix.collapser.HystrixCollapserKey.timerDelayInMilliseconds 如何设置默认实例 HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(int value) requestCache.enabled此属性指示是否为HystrixCollapser.execute()和HystrixCollapser.queue()调用启用了请求缓存。 默认值 true 默认属性 hystrix.collapser.default.requestCache.enabled 实例属性 hystrix.collapser.HystrixCommandKey.requestCache.enabled 如何设置默认实例 HystrixCollapserProperties.Setter().withRequestCacheEnabled(boolean value) 线程池属性（Thread Pool Properties）以下属性控制Hystrix命令执行的线程池的行为。请注意，这些名称与ThreadPoolExecutor Javadoc中的名称相匹配 大多数情况下，10个线程的默认值都可以（通常可以做得更小）。 要确定是否需要更大，计算大小的基本公式是： 在健康时每秒的请求高峰数 × 99%的延迟秒数+一些喘息的空间时。 看下面的例子，看看这个公式是如何实施的。 总体原则是尽可能保持池的小，因为它是减轻负载并防止资源在延迟发生时被阻塞的主要工具。 Netflix API有30+的线程池被设置为10，两个在20，一个在25。 上图显示了一个配置示例，其中依赖关系没有理由达到第99.5百分位，因此它在网络超时层将其缩短，并立即重试，并期望大部分时间会得到中位延迟能够在300ms线程超时内完成这一切。 如果依赖有合法的理由有时达到99.5％（比如缓存未命中），那么网络超时将被设置得比它高，比如325ms，重试0或1次，线程超时设置更高（350ms + ）。 线程池的大小为10，以处理第99个百分点请求的突发，但是当一切正常时，此线程池通常在任何给定时间通常只有1或2个线程处于活动状态，以服务大多数40ms的中间调用。 当你正确地配置它时，HystrixCommand层的超时应该是很少的，但是如果网络等待时间以外的事情影响了时间，或者在最坏的情况下连接+读+重试+连接+读超过配置的整体超时。 每个方向的配置和折衷的攻击性对于每个依赖性是不同的。 当性能特征发生变化或发现问题时，您可以根据需要实时更改配置，而且如果出现问题或配置错误，则无需关闭整个应用程序。 coreSize此属性设置核心线程数。 默认值 10 默认属性 hystrix.threadpool.default.coreSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.coreSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withCoreSize(int value) maximumSize在1.5.9中添加。该属性设置最大的线程池大小。这是开始无需拒绝HystrixCommand即可支持的最大并发数量。请注意，如果您还设置了allowMaximumSizeToDivergeFromCoreSize，则此设置才会生效。在1.5.9之前，核心和最大大小总是相等的。 默认值 10 默认属性 hystrix.threadpool.default.maximumSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.maximumSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMaximumSize(int value) maxQueueSize该属性设置BlockingQueue实现的最大队列大小。 如果将其设置为-1，则将使用SynchronousQueue，其它正值将使用LinkedBlockingQueue。 注意： 这个属性只适用于初始化时间，因为如果不重新初始化线程执行器，不支持的队列被调整或改变。 如果您需要越过此限制并允许在队列中进行动态更改，请参阅queueSizeRejectionThreshold属性。 要在SynchronousQueue和LinkedBlockingQueue之间切换，需要重新启动。 默认值 -1 默认属性 hystrix.threadpool.default.maxQueueSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.maxQueueSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMaxQueueSize(int value) queueSizeRejectionThreshold此属性设置队列大小拒绝阈值 —— 即使maxQueueSize尚未达到，拒绝将发生的人为最大队列大小。此属性的存在是因为BlockingQueue的maxQueueSize不能动态更改，我们希望允许您动态更改影响拒绝的队列大小。 当排队一个线程执行时，HystrixCommand使用它。 注意： 如果maxQueueSize == -1，则此属性不适用。 默认值 5 默认属性 hystrix.threadpool.default.queueSizeRejectionThreshold 实例属性 hystrix.threadpool.HystrixThreadPoolKey.queueSizeRejectionThreshold 如何设置默认实例 HystrixThreadPoolProperties.Setter().withQueueSizeRejectionThreshold(int value) keepAliveTimeMinutes该属性设置保持活动时间，以分钟为单位。 在1.5.9之前，所有线程池都是固定大小的，如coreSize == maximumSize。在1.5.9之后，将allowMaximumSizeToDivergeFromCoreSize设置为true允许这两个值发散，以便线程池可以获取/释放线程。如果coreSize &lt;maximumSize，那么这个属性控制一个线程在被释放之前将不被使用的时间。 默认值 1 默认属性 hystrix.threadpool.default.keepAliveTimeMinutes 实例属性 hystrix.threadpool.HystrixThreadPoolKey.keepAliveTimeMinutes 如何设置默认实例 HystrixThreadPoolProperties.Setter().withKeepAliveTimeMinutes(int value) allowMaximumSizeToDivergeFromCoreSize在1.5.9中添加。此属性允许maximumSize的配置生效。该值可以等于或高于coreSize。设置coreSize &lt;maximumSize会创建一个线程池，它可以支持maximumSize并发性，但是会在相对不活动的时间内将线程返回给系统。 （以keepAliveTimeInMinutes为准） 默认值 false 默认属性 hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.allowMaximumSizeToDivergeFromCoreSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withAllowMaximumSizeToDivergeFromCoreSize(boolean value) metrics.rollingStats.timeInMilliseconds该属性设置统计滚动窗口的持续时间，以毫秒为单位。这是为线程池保留多长时间的指标。 窗口根据这些增量被分成桶和“卷”。 默认值 10000 默认属性 hystrix.threadpool.default..metrics.rollingStats.timeInMilliseconds 实例属性 hystrix.threadpool.HystrixThreadPoolKey.metrics.rollingStats.timeInMilliseconds 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMetricsRollingStatisticalWindowInMilliseconds(int value) metrics.rollingStats.numBuckets该属性设置滚动统计窗口分成的桶的数量。 注意： 必须要确保如下条件：“metrics.rollingStats.timeInMilliseconds ％ metrics.rollingStats.numBuckets == 0” ，否则会引发异常。 换句话说，10000/10是可以的，10000/20也可以，但是10000/7不行。 默认值 10 取值范围 能被metrics.rollingStats.timeInMilliseconds整除的任何值，结果应该是数百或数千毫秒的桶。大容量的性能还没有测试过小于100ms的桶。 默认属性 hystrix.threadpool.default.metrics.rollingStats.numBuckets 实例属性 hystrix.threadpool.HystrixThreadPoolKey.metrics.rollingStats.numBuckets 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMetricsRollingStatisticalWindowBuckets(int value) 参考资料https://github.com/Netflix/Hystrix/wiki/Configuration table th:first-of-type{width:80px}]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hystrix</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS下基于Python2.7安装OpenCV3]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FMacOs-install-opencv.html</url>
    <content type="text"><![CDATA[步骤概览安装Xcode以及Apple Command Line Tools安装Homebrew创建Python虚拟环境安装NumPy安装OpenCV安装Xcode以及Apple Command Line Tools从App Store下载并安装Xcode。接受Apple开发者协议。1sudo xcodebuild -license 安装Apple Command Line Tools 1sudo xcode-select --install 输入上面的命令后，会弹出一个窗口，确认你想要安装命令行工具，点击install或安装按钮进行安装。 安装HomebrewHomebrew是MacOS的包管理器，类似于Ubuntu的apt-get。 安装命令： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 一旦安装了Homebrew，您应该对其进行更新，以确保下载最新的软件包定义： 1brew update 修改环境变量文件，如果你用的是bash请球盖vi ~/.bash_profile，如果你用的是zsh请修改vi ~/.zshrc，添加如下内容到对应的文件： 12# Homebrewexport PATH=/usr/local/bin:$PATH 使用source命名来让配置生效：source ~/.bash_profile 或 source ~/.zshrc。 创建Python虚拟环境 MacOS默认已安装Python，不同的MacOS版本可能对应的Python版本不同。可以使用python --version来获取当前系统中的Python版本。如果当前版本不是2.7.x，可以使用Homebrew来安装： 1brew install python 安装完成之后，我们需要把操作系统的python链接到Homebrew的安装目录： 1brew linkapps python 检查安装是否正确： 1which python 如果输出的路径是/usr/local/bin/python则说明安装Python成功。 安装虚拟环境 由于在OS X El Capitan中，在内核下引入了Rootless机制，即使root用户也无法对/System、/bin、/sbin、/usr(except /usr/local)目录有写和执行权限，只有Apple以及Apple授权签名的软件（包括命令行工具）可以修改此目录。 因此在使用操作系统自带的Python时，使用pip安装某些包时会存在失败的情况。所以我们在这里使用python虚拟环境来规避这个问题。 1pip install virtualenv virtualenvwrapper 安装完成之后，我们需要再次修改环境变量文件，如果你用的是bash请球盖vi ~/.bash_profile，如果你用的是zsh请修改vi ~/.zshrc，添加如下内容到对应的文件： 12# Virtualenv/VirtualenvWrappersource /usr/local/bin/virtualenvwrapper.sh 使用source命名来让配置生效：source ~/.bash_profile 或 source ~/.zshrc。 创建虚拟环境 1mkvirtualenv opencv 上面命名创建了一个名叫opencv的虚拟环境，你可以使用workon opencv进入虚拟环境，也可以使用deactivate指令从虚拟环境中退出。 安装NumPy 进入虚拟环境: workon opencv pip install numpy 安装OpenCV 环境准备： 123brew install cmake pkg-configbrew install jpeg libpng libtiff openexrbrew install eigen tbb 从github下载OpenCV3 123cd ~git clone https://github.com/opencv/opencvgit clone https://github.com/opencv/opencv_contrib 下载完成之后，进入源码目录切换到指定的版本，譬如安装OpenCV的3.3.1版本： 1234cd ~/opencvgit checkout -b 3.3.1 3.3.1cd ~/opencv_contribgit checkout -b 3.3.1 3.3.1 配置CMake 123cd ~/opencvmkdir buildcd build 接着我们就可以执行cmake命令了，但在执行命令之前有两个参数需要调整： 1234567891011cmake -D CMAKE_BUILD_TYPE=RELEASE \-D CMAKE_INSTALL_PREFIX=/usr/local \-D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib/modules \-D PYTHON2_LIBRARY=YYY \-D PYTHON2_INCLUDE_DIR=ZZZ \-D PYTHON2_EXECUTABLE=/usr/local/bin/python \-D BUILD_opencv_python2=ON \-D BUILD_opencv_python3=OFF \-D INSTALL_PYTHON_EXAMPLES=ON \-D INSTALL_C_EXAMPLES=OFF \-D BUILD_EXAMPLES=ON .. cmake重要参数解释： BUILD_opencv_python2=ON：这表明我们要基于Python2.7来安装OpenCV 3； BUILD_opencv_python3=OFF：这表明我们关闭Python3； PYTHON2_LIBRARY=YYY：这是你自己填写的第一个值。您将需要用您的libpython2.7.dylib文件的路径替换YYY（我将帮助您在下一节中找到它）； PYTHON2_INCLUDE_DIR=ZZZ：这是您需要填写的第二个值。您需要将ZZZ替换为Python.h头文件所在目录的路径（同样，我将帮助您确定此路径） 获取PYTHON2_LIBRARY的路径 1ls /usr/local/Cellar/python/2.7.*/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config/libpython2.7.dylib 将上面的输出拷贝出来替换掉PYTHON2_LIBRARY=YYY中的YYY。 获取PYTHON2_INCLUDE_DIR的路径 1ls -d /usr/local/Cellar/python/2.7.*/Frameworks/Python.framework/Versions/2.7/include/python2.7/ 将上面的输出拷贝出来替换掉PYTHON2_INCLUDE_DIR=ZZZ中的ZZZ。 替换完成之后即可执行。 编译与安装 1make -j4 -j开关控制并发编译OpenCV的处理器数量，因为我在四核系统上，所以我用-j4。编译可能需要几十分钟左右。 如果编译没有出错就可以进行安装了 1sudo make install 安装成功后，可以在/usr/local/lib/python2.7/site-packges/下找到cv2.so文件。 在虚拟环境中添加cv2.so的软连接 12cd ~/.virtualenvs/cv/lib/python2.7/site-packages/ln -s /usr/local/lib/python2.7/site-packages/cv2.so cv2.so cv2.so 测试与验证OpenCV 打开一个新的终端： 123456789$ workon opencv$ pythonPython 2.7.12 (default, Oct 11 2016, 05:20:59) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import cv2&gt;&gt;&gt; cv2.__version__'3.3.1&gt;&gt;&gt; 如何完整的卸载OpenCV? 可以通过进入之前的build目录，执行make uninstall来完整卸载OpenCV. 参考资料 MacOS基于Python2.7安装OpenCV3 MacOS基于Python3.5安装OpenCV3]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geetest拖拽验证码破解思路（java）]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FGeetest-Crack.html</url>
    <content type="text"><![CDATA[项目中有个需求希望能获取公司的工商注册信息，刚开始是想与第三方数据公司合作，因种 种原因合作没有达成。于是想做个爬虫直接从工商局的《企业信用信息公示系统》中获取。 要想从《企业信用信息公示系统》中爬取数据，首先必须解决掉Geetest验证码的问题。 经过一系列的摸索，发现要想破解geetest的验证码，主要需要解决如下几个问题：背景图的还原找到背景图中缺口的位置将滑块拖拽到缺口背景图的还原Geetest背景图分为两张，一张是完整背景图，一张是带缺口的背景图。每张图片被分成 52 份， 上下两部分各 26 份，然后乱序排列。在网页上显示时，是通过css来将乱序的 碎片重新组列成完整的图片。乱序图片：正常图片：因此，我们必须将原始的背景乱序图片切根据页面上的css样式将图片切割成 52 份，并 按照先后顺序拼接还原成正确的图片。需要使用到java.awt.image.BufferedImage类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 将Geetest打乱的图片还原，Geetest的原始背景图是分成52份碎片乱序组合的。目前是上下各26份，每份碎片图片宽10px， 高58px。 * * @param image 原始背景图 * @param locations 展示位置列表，数据结构：[&#123;x=-25, y=-58&#125;, ...] * @return 顺序排列好的图片 */public static BufferedImage recover(BufferedImage image, List&lt;Map&lt;String, Integer&gt;&gt; locations) throws IOException &#123; long begin = System.currentTimeMillis(); int per_image_with = 10; // 每张碎片图片的宽度 int per_image_height = 58; // 每张碎片图片的高度 List&lt;BufferedImage&gt; upperList = new ArrayList&lt;&gt;(); List&lt;BufferedImage&gt; downList = new ArrayList&lt;&gt;(); // 将原始图片裁剪成碎片 for (Map&lt;String, Integer&gt; location : locations) &#123; int x = location.get("x"); int y = location.get("y"); if (y == -58) &#123; upperList.add(image.getSubimage(abs(x), 58, per_image_with, per_image_height)); &#125; else if (y == 0) &#123; downList.add(image.getSubimage(abs(x), 0, per_image_with, per_image_height)); &#125; &#125; BufferedImage newImage = new BufferedImage(upperList.size() * per_image_with, image.getHeight(), image.getType()); // 重绘图片的上半部分 int x_offset = 0; for (BufferedImage bufferedImage : upperList) &#123; Graphics graphics = newImage.getGraphics(); graphics.drawImage(bufferedImage, x_offset, 0, null); x_offset += bufferedImage.getWidth(); &#125; // 重绘图片的下半部分 x_offset = 0; for (BufferedImage bufferedImage : downList) &#123; Graphics graphics = newImage.getGraphics(); graphics.drawImage(bufferedImage, x_offset, 58, null); x_offset += bufferedImage.getWidth(); &#125; log.debug("还原图片耗时：&#123;&#125;ms", System.currentTimeMillis() - begin); return newImage;&#125; 找到背景图中缺口的位置 正常图片： 缺口图片： Geetest验证时，只需要将拼图块水平移动到正确的位置即可。因此通过上面两张图片比 对，发现我们只要找到缺口的x坐标即可。 这里我借用的参考内容的方法：两张原始图的大小都是相同的 260*116，那就通过两个 for 循环依次对比每个像素点的 RGB 值，如果相差超过 50 则就认为找到了缺口的位置。 12345678910111213141516171819202122232425262728293031323334353637/** * 计算验证图的缺口位置（x轴） 两张原始图的大小都是相同的260*116，那就通过两个for循环依次对比每个像素点的RGB值， 如果RGB三元素中有一个相差超过50则就认为找到了缺口的位置 * * @param image1 图像1 * @param image2 图像2 * @return 缺口的x坐标 */public static int getDiffX(BufferedImage image1, BufferedImage image2) &#123; long begin = System.currentTimeMillis(); for (int x = 0; x &lt; image1.getWidth(); x++) &#123; for (int y = 0; y &lt; image1.getHeight(); y++) &#123; if (!isSimilar(image1, image2, x, y)) &#123; return x; &#125; &#125; &#125; log.debug("图片对比耗时：&#123;&#125;ms", System.currentTimeMillis() - begin); return 0;&#125;/** * 判断image1, image2的[x, y]这一像素是否相似，如果该像素的RGB值相差都在50以内，则认为相似。 * * @param image1 图像1 * @param image2 图像2 * @param x_offset x坐标 * @param y_offset y坐标 * @return 是否相似 */public static boolean isSimilar(BufferedImage image1, BufferedImage image2, int x_offset, int y_offset) &#123; Color pixel1 = new Color(image1.getRGB(x_offset, y_offset)); Color pixel2 = new Color(image2.getRGB(x_offset, y_offset)); return abs(pixel1.getBlue() - pixel2.getBlue()) &lt; 50 &amp;&amp; abs(pixel1.getGreen() - pixel2.getGreen()) &lt; 50 &amp;&amp; abs(pixel1.getRed() - pixel2.getRed()) &lt; 50;&#125; 将滑块拖拽到缺口Geetest在拖拽拼图块时，对拼图块的移动轨迹做了一些 “ 人工智能 ” 的算法识别，使 用程序直接将拼图块拖入缺口时，发现有很大的概率会被识别为机器操作，页面显示怪物 吃掉了饼图。因此我们需要采用一些算法来模拟人拖拽的行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/** * 根据缺口位置x_offset，仿照手动拖动滑块时的移动轨迹。 * 手动拖动滑块有几个特点： * 开始时拖动速度快，最后接近目标时会慢下来； * 总时间大概1~3秒； * 有可能会拖超过后再拖回头； * * @return 返回一个轨迹数组，数组中的每个轨迹都是[x,y,z]三元素：x代表横向位移，y代表竖向位移，z代表时间间隔，单位毫秒 */private static List&lt;Map&lt;String, Integer&gt;&gt; getTrack(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks; long begin = System.currentTimeMillis(); // 实际上滑块的起始位置并不是在图像的最左边，而是大概有6个像素的距离，所以滑动距离要减掉这个长度 x_offset = x_offset - 6; if (getRandom(0, 10) % 2 == 0) &#123; tracks = strategics_1(x_offset); &#125; else &#123; tracks = strategics_2(x_offset); &#125; log.debug("生成轨迹耗时: &#123;&#125;ms", System.currentTimeMillis() - begin); log.debug("计算出移动轨迹: &#123;&#125;", tracks); return tracks;&#125;/** * 轨迹策略1 */private static List&lt;Map&lt;String, Integer&gt;&gt; strategics_1(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks = new ArrayList&lt;&gt;(); float totalTime = 0; int x = getRandom(1, 3); // 随机按1~3的步长生成各个点 while (x_offset - x &gt;= 5) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", x); point.put("y", 0); point.put("z", 0); tracks.add(point); x_offset = x_offset - x; x = getRandom(1, 5); totalTime += point.get("z").floatValue(); &#125; // 后面几个点放慢时间 for (int i = 0; i &lt; x_offset; i++) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", 1); point.put("y", 0); point.put("z", getRandom(10, 200)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; log.debug("预计拖拽耗时: &#123;&#125;ms", totalTime); return tracks;&#125;/** * 轨迹策略2 */private static List&lt;Map&lt;String, Integer&gt;&gt; strategics_2(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks = new ArrayList&lt;&gt;(); float totalTime = 0; int dragX = 0; // 已拖拽的横向偏移量 int nearRange = getRandom(5, 10); // 靠近缺口的范围 while (dragX &lt; x_offset - nearRange) &#123; // 生成快速拖拽点，拖拽距离非常靠近切口 int stepLength = getRandom(1, 5); // 随机按1~5的步长生成各个点 Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", stepLength); point.put("y", 0); point.put("z", getRandom(0, 2)); tracks.add(point); totalTime += point.get("z").floatValue(); dragX += stepLength; &#125; // 随机一定的比例将滑块拖拽过头 if (getRandom(0, 99) % 2 == 0) &#123; int stepLength = getRandom(10, 15); // 随机按1~5的步长生成各个点 Map&lt;String, Integer&gt; attachPoint = new HashMap&lt;&gt;(3); attachPoint.put("x", stepLength); attachPoint.put("y", 0); attachPoint.put("z", getRandom(0, 2)); tracks.add(attachPoint); dragX += stepLength; totalTime += attachPoint.get("z").floatValue(); &#125; // 精确点 for (int i = 0; i &lt; Math.abs(dragX - x_offset); i++) &#123; if (dragX &gt; x_offset) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", -1); point.put("y", 0); point.put("z", getRandom(10, 100)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; else &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", 1); point.put("y", 0); point.put("z", getRandom(10, 100)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; &#125; log.debug("预计拖拽耗时: &#123;&#125;ms", totalTime); return tracks;&#125;/** * 根据移动轨迹，模拟拖动极验的验证滑块 */private static boolean simulateDrag(WebDriver webDriver, Site site, List&lt;Map&lt;String, Integer&gt;&gt; tracks) throws InterruptedException &#123; log.debug("开始模拟拖动滑块"); WebElement slider = webDriver.findElement(By.cssSelector(site.getGeetest().getSliderKnob())); log.debug("滑块初始位置: &#123;&#125;", slider.getLocation()); Actions actions = new Actions(webDriver); actions.clickAndHold(slider).perform(); for (Map&lt;String, Integer&gt; point : tracks) &#123; int x = point.get("x") + 22; int y = point.get("y") + 22; actions.moveToElement(slider, x, y).perform(); int z = point.get("z"); TimeUnit.MILLISECONDS.sleep(z); &#125; TimeUnit.MILLISECONDS.sleep(getRandom(100, 200)); // 随机停顿100~200毫秒 actions.release(slider).perform(); TimeUnit.MILLISECONDS.sleep(100); // 等待0.1秒后检查结果 try &#123; // 在5秒之内检查弹出框是否消失，如果消失则说明校验通过；如果没有消失说明校验失败。 new WebDriverWait(webDriver, 5).until((ExpectedCondition&lt;Boolean&gt;) driver -&gt; &#123; try &#123; WebElement popupElement = driver.findElement(By.cssSelector(site.getGeetest().getPopupWrap())); return !popupElement.isDisplayed(); &#125; catch (NoSuchElementException e) &#123; return true; // 元素不存在也返回true &#125; &#125;); return true; &#125; catch (Exception e) &#123; return false; &#125;&#125; 总结解决好上面的三点之后，Geetest验证基本就破解掉了，但是要爬取企业信用信息公示系统中的数据还有一些事情要做。目前工商局有多个地区系统，每个系统的页面解析处理也不一样。某些地区系统甚至还针对访问频次做了控制，你可以通过 IP 代理来解决。 完整的代码示例请参考: https://github.com/aqlu/geetest-crack 运行效果： 本文的参考资料：http://blog.csdn.net/paololiu/article/details/52514504]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>geetest</tag>
        <tag>验证码破解</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS科学上网]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FMacOs-scientific-Surf-the-Internet.html</url>
    <content type="text"><![CDATA[本文将介绍如何在MacOS上采用VMess协议与墙外VPS通信，其中主要用到了[v2ray]这款开源工具。服务端安装(Centos)因为我选择的VPS的Centos的操作系统，所以此章节主要基于Centos操作系统来描述。安装包下载：wget https://github.com/v2ray/v2ray-core/releases/download/v2.40/v2ray-linux-64.zip解压安装包到/opt目录：unzip v2ray-linux-64.zip -d /opt编写配置文件:12cd /opt/v2ray-v2.40-linux-64vi config.json config.json内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "log" : &#123; // 日志输出配置 "access": "/var/log/v2ray/access.log", "error": "/var/log/v2ray/error.log", "loglevel": "warning" &#125;, // 对外提供 vmess 协议 "inbound": &#123; "port": 28399, // 监听端口 "protocol": "vmess", "settings": &#123; "clients": [&#123; "id": "3b129ddd-72a3-4d28-aeee-028a0fe86e33", // 可以随机生成一个，但必须保证服务端ID与客户端ID必须保持一致 "level": 1, "alterId": 64, "security": "aes-128-gcm" &#125;] &#125; &#125;, "outbound": &#123; "protocol": "freedom", "settings": &#123;&#125; &#125;, "routing": &#123; "strategy": "rules", "settings": &#123; "rules": [&#123; "type": "field", "ip": [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "::1/128", "fc00::/7", "fe80::/10" ], "outboundTag": "blocked" &#125;] &#125; &#125;&#125; 启动v2ray服务：/opt/v2ray-v2.40-linux-64/v2ray -config=/opt/v2ray-v2.40-linux-64/config.json &gt; v2ray.log &amp; 客户端安装(MacOs) 安装包下载：wget https://github.com/v2ray/v2ray-core/releases/download/v2.40/v2ray-macos.zip 解压安装包到/usr/local/opt目录：unzip v2ray-linux-64.zip -d /usr/local/opt 编写配置文件: 12cd /usr/local/opt/v2ray-v2.40-linux-64vi config.json config.json内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; "log" : &#123; "access": "/var/log/v2ray/access.log", "error": "/var/log/v2ray/error.log", "loglevel": "warning" &#125;, // 对外提供 socks5 协议 "inbound": &#123; "port": 1080, // 监听端口 "protocol": "socks", // 入口协议为 SOCKS 5 "settings": &#123; "auth": "noauth" //socks的认证设置，noauth 代表不认证，由于 socks 通常在客户端使用，所以这里不认证 &#125; &#125;, "outbound": &#123; "protocol": "vmess", // 出口协议，对应服务端的入口协议 "settings": &#123; "vnext": [&#123; "address": "serveraddr.com", // 服务器地址，请修改为你自己的服务器 ip 或域名 "port": 28399, // 服务器端口，对应服务器端入口的端口 "users": [&#123; "id": "3b129ddd-72a3-4d28-aeee-028a0fe86e33", // 用户ID, 服务端ID与客户端ID必须保持一致 "alterId": 64 // 此处的值也应当与服务器相同 &#125;] &#125;] &#125; &#125;, "routing": &#123; "strategy": "rules", "settings": &#123; "rules": [&#123; "type": "field", "ip": [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "::1/128", "fc00::/7", "fe80::/10" ], "outboundTag": "blocked" &#125;] &#125; &#125;&#125; 启动v2ray服务：/usr/local/opt/v2ray-v2.40-linux-64/v2ray -config=/usr/local/opt/v2ray-v2.40-linux-64/config.json &gt; v2ray.log &amp; 客户端安装的另一种方式（基于Docker安装） 下载镜像： docker pull v2ray/official 编写配置文件： 123mkdir -p ~/v2raycd ~/v2rayvi config.json # 内容请参考客户端安装(MacOs) 创建容器： 1docker run -d --restart=always --name v2ray -v ~/v2ray:/etc/v2ray -p 1080:1080 v2ray/official v2ray -config=/etc/v2ray/config.json -p 后面跟的端口为config.json中inbound配置的监听端口 校验容器是否创建成功：docker container ls 启动容器：docker start 停止v2ray：docker stop v2ray 重启v2ray：docker restart v2ray 查看日志：docker container log v2ray 更多参考资料 项目：https://github.com/v2ray/v2ray-core 用户手册：https://www.v2ray.com/ 其它文档：https://toutyrater.github.io/]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>vmess</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F%2Fhello-world.html</url>
    <content type="text"><![CDATA[Hello World!这是我的第一篇博客，感谢Hexo提供了一个简单好用的博客框架，感谢NexT优雅的的主题。此博客是本人的一个杂记。为什么叫杂记？其实就是一些乱七八糟的东西，可能是曾经的一些技术笔记，也可能是一些技术专题的连载，也可能是一些生活观点与琐事。]]></content>
  </entry>
</search>
