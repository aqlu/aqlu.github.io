<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hystrix 配置属性参考]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2FJava%2FHystrix-configuration.html</url>
    <content type="text"><![CDATA[介绍Hystrix使用Archaius作为配置属性的默认实现。下面的文档描述了默认使用的HystrixPropertiesStrategy实现，你也可以使用插件的方式来覆盖它。每个属性有四个优先级：代码的全局默认值如果没有设置以下3个，则这是默认值。 全局默认值在下表中显示为 “默认值”。动态全局默认属性你可以使用属性更改全局默认值。 全局默认属性名称在下表中显示为 “默认属性”。用代码定义默认实例属性你可以定义特定于实例的默认值。例：1HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(int value) 你需要类似于以下的方式将这种命令插入到HystrixCommand构造函数中： 12345public HystrixCommandInstance(int id) &#123; super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ExampleGroup")) .andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(500))); this.id = id;&#125; 一般的设置初始值可以采用便利的构造函数方式。这是一个例子： 1234public HystrixCommandInstance(int id) &#123; super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"), 500); this.id = id;&#125; 动态设置实例属性 你可以动态设置实例特定的值，从而覆盖前面三个默认级别。 动态实例属性名称在下表中显示为 “实例属性”。 例： 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutInMilliseconds 将属性的HystrixCommandKey部分替换为您所定位的HystrixCommand的HystrixCommandKey.name())值。 例如，如果被命名为“SubscriberGetAccount”，则属性名称将是： hystrix.command.SubscriberGetAccount.execution.isolation.thread.timeoutInMilliseconds 命令属性（Command Properties）以下属性将控制HystrixCommand的行为： 执行（Execution）以下属性控制HystrixCommand.run())执行。 execution.isolation.strategy这个属性指示HystrixCommand.run()执行的隔离策略，有以下两种选择之一： THREAD —— 它在单独的线程上执行，并发请求受线程池中线程数量的限制 SEMAPHORE —— 它在调用线程上执行，并发请求受信号计数的限制 线程或信号量 缺省值和建议的设置是运行HystrixCommand时使用线程隔离（THREAD），和运行HystrixObservableCommand时使用信号隔离（SEMAPHORE）。 在线程中执行命令能对网络超时提供另一层保护。 通常情况下，对于HystrixCommand来说，唯一使用信号量隔离的场景是，当调用量非常大（每秒数百次）时单独线程的开销太高；这通常只适用于非网络调用。 Netflix的API在40+线程池中运行100+命令，并且只有少数命令不在线程中运行 —— 那些从内存中的缓存提取元数据或或是门面到线程隔离命令（更多信息请参见Primary + Secondary with Fallback” pattern）。 更多信息请参见隔离是如何工作的。 默认值 THREAD（参见：ExecutionIsolationStrategy.THREAD） 取值范围 THREAD, SEMAPHORE 默认属性 hystrix.command.default.execution.isolation.strategy 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.strategy 如何设置默认实例 // to use thread isolation HystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD) // to use semaphore isolation HystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE) execution.isolation.thread.timeoutInMilliseconds该属性设置以毫秒为单位，在该时间之后，调用者将观察到超时并离开命令执行。 Hystrix将HystrixCommand标记为TIMEOUT，并执行回退逻辑。请注意，如果需要可以为每个命令配置关闭超时的设置（请参阅command.timeout.enabled）。 注意： 超时将在HystrixCommand.queue()上触发，即使调用者从未在生成的Future上调用get()。在Hystrix 1.4.0之前，只有调用get()才能使超时机制在这种情况下生效。 默认值 1000 默认属性 hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(int value) execution.timeout.enabled该属性指示HystrixCommand.run()执行是否应该有一个超时。 默认值 true 默认属性 hystrix.command.default.execution.timeout.enabled 实例属性 hystrix.command.HystrixCommandKey.execution.timeout.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionTimeoutEnabled(boolean value) execution.isolation.thread.interruptOnTimeout这个属性指示HystrixCommand.run()执行是否应该在发生超时时被中断。 默认值 true 默认属性 hystrix.command.default.execution.isolation.thread.interruptOnTimeout 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnTimeout 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionIsolationThreadInterruptOnTimeout(boolean value) execution.isolation.thread.interruptOnCancel这个属性指示HystrixCommand.run()执行是否应该在发生取消时被中断。 默认值 false 默认属性 hystrix.command.default.execution.isolation.thread.interruptOnCancel 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnCancel 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionIsolationThreadInterruptOnCancel(boolean value) execution.isolation.semaphore.maxConcurrentRequests当您使用ExecutionIsolationStrategy.SEMAPHORE时，此属性设置允许HystrixCommand.run()方法的最大请求数。 如果达到这个最大并发限制，则后续请求将被拒绝。 当你选择一个信号量时，你使用的逻辑基本上和你选择线程池中添加多少个线程相同，但是信号量的开销要小得多，通常执行速度要快得多（亚毫秒） ，否则你会使用线程。 例如，5000rps的单个实例在内存中查找指标聚集仅需要2个信号量就能工作。 隔离原理仍然是相同的，所以信号量应该仍然是整个容器（如：Tomcat）线程池的一小部分，而不是全部或大部分，否则它不提供保护。 默认值 10 默认属性 hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests 实例属性 hystrix.command.HystrixCommandKey.execution.isolation.semaphore.maxConcurrentRequests 如何设置默认实例 HystrixCommandProperties.Setter().withExecutionIsolationSemaphoreMaxConcurrentRequests(int value) 回退（Fallback）以下属性控制HystrixCommand.getFallback()如何执行。这些属性适用于ExecutionIsolationStrategy.THREAD和ExecutionIsolationStrategy.SEMAPHORE。 fallback.isolation.semaphore.maxConcurrentRequests该属性设置HystrixCommand.getFallback()方法允许从调用线程中创建的最大请求数。 如果达到最大并发限制，则随后的请求将被拒绝并抛出异常，因为没有回退被提取到。 默认值 10 默认属性 hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests 实例属性 hystrix.command.HystrixCommandKey.fallback.isolation.semaphore.maxConcurrentRequests 如何设置默认实例 HystrixCommandProperties.Setter().withFallbackIsolationSemaphoreMaxConcurrentRequests(int value) fallback.enabledSince: 1.2 该属性设置是否在发生故障或拒绝时尝试调用HystrixCommand.getFallback()。 默认值 true 默认属性 hystrix.command.default.fallback.enabled 实例属性 hystrix.command.HystrixCommandKey.fallback.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withFallbackEnabled(boolean value) 断路器（Circuit Breaker）断路器属性控制HystrixCircuitBreaker的行为。 circuitBreaker.enabled该属性设置是否将使用断路器来跟踪健康状况并且如果断路器跳闸则将其短路。 默认值 true 默认属性 hystrix.command.default.circuitBreaker.enabled 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerEnabled(boolean value) circuitBreaker.requestVolumeThreshold该属性设置滚动窗口中将使电路跳闸的最小请求数量。 例如，如果值是20，那么如果在滚动窗口中接收到19个请求（例如10秒的窗口），则即使所有19个请求都失败，电路也不会跳闸。 默认值 20 默认属性 hystrix.command.default.circuitBreaker.requestVolumeThreshold 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.requestVolumeThreshold 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerRequestVolumeThreshold(int value) circuitBreaker.sleepWindowInMilliseconds该属性设置跳闸后的时间量，拒绝请求，然后再次尝试确定电路是否应再次闭合。 默认值 5000 默认属性 hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.sleepWindowInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerSleepWindowInMilliseconds(int value) circuitBreaker.errorThresholdPercentage该属性设置错误百分比，在该值以上，电路应断开并开始将请求短路到回退逻辑。 默认值 50 默认属性 hystrix.command.default.circuitBreaker.errorThresholdPercentage 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.errorThresholdPercentage 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerErrorThresholdPercentage(int value) circuitBreaker.forceOpen如果该属性为真，则强制断路器进入打开（跳闸）状态，将拒绝所有的请求。 此属性优先于circuitBreaker.forceClosed。 默认值 false 默认属性 hystrix.command.default.circuitBreaker.forceOpen 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.forceOpen 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerForceOpen(boolean value) circuitBreaker.forceClosed如果该属性为真，则强制断路器进入关闭状态，在该状态下将允许请求，而不管错误百分比如何。 circuitBreaker.forceOpen属性优先，所以如果它被设置为true，这个属性什么都不做。 默认值 false 默认属性 hystrix.command.default.circuitBreaker.forceClosed 实例属性 hystrix.command.HystrixCommandKey.circuitBreaker.forceClosed 如何设置默认实例 HystrixCommandProperties.Setter().withCircuitBreakerForceClosed(boolean value) 度量（Mitrics）以下属性与从HystrixCommand和HystrixObservableCommand执行捕获指标有关。 metrics.rollingStats.timeInMilliseconds该属性设置统计滚动窗口的持续时间，以毫秒为单位。这是Hystrix保持断路器使用和发布指标的时间。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 窗口根据这些增量被分成桶和“卷”。 例如，如果将此属性设置为10秒（10000），具有十个1秒桶的，则下图显示了如何将新桶和旧桶关闭： 默认值 10000 默认属性 hystrix.command.default.metrics.rollingStats.timeInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingStats.timeInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingStatisticalWindowInMilliseconds(int value) metrics.rollingStats.numBuckets该属性设置滚动统计窗口分成的桶的数量。 注意： 必须要确保如下条件： “metrics.rollingStats.timeInMilliseconds ％ metrics.rollingStats.numBuckets == 0” ， 否则会引发异常。 换句话说，10000/10是可以的，10000/20也行，但是10000/7不行。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 10 取值范围 可以被metric.rollingStats.timeInMilliseconds整除的任何值。结果应该是数百或数千毫秒的桶。大容量的性能还没有测试过小于100ms的桶。 默认属性 hystrix.command.default.metrics.rollingStats.numBuckets 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingStats.numBuckets 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingStatisticalWindowBuckets(int value) metrics.rollingPercentile.enabled这个属性表示执行延迟是否应该跟踪和计算为百分比。如果他们被禁用，则所有汇总统计（平均值，百分位数）返回为-1。 默认值 true 默认属性 hystrix.command.default.metrics.rollingPercentile.enabled 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileEnabled(boolean value) metrics.rollingPercentile.timeInMilliseconds此属性设置滚动窗口的持续时间，在该窗口中保留执行时间以允许百分数计算（以毫秒为单位）。 窗口根据这些增量被分成桶和“卷”。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 6000 默认属性 hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.timeInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileWindowInMilliseconds(int value) metrics.rollingPercentile.numBuckets这个属性设置了rollingPercentile窗口将被分成的桶的数量。 注意： 必须要确保如下条件：“metrics.rollingPercentile.timeInMilliseconds ％ metrics.rollingPercentile.numBuckets == 0” ，否则会引发异常。 换句话说，60000/6是可以的，60000/60也是可以的，但10000/7不行。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 6 取值范围 可以被metric.rollingPercentile.timeInMilliseconds整除的任何值。结果应该是数千毫秒的桶。大容量的性能还没有测试过小于1000ms的桶。 默认属性 hystrix.command.default.metrics.rollingPercentile.numBuckets 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.numBuckets 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileWindowBuckets(int value) metrics.rollingPercentile.bucketSize该属性设置每个桶的最大执行次数。如果更多的执行在此期间发生，他们将环绕并开始在桶的开头重写。 例如，如果桶大小设置为100，并桶的窗口为10秒，但是在此期间发生500次执行，则只有最后100次执行将保留在该10秒的桶中。 如果增加这个大小，这也增加了存储值所需的内存量，并增加了对列表进行排序以进行百分比计算所需的时间。 从1.4.12开始，此属性仅影响初始度量标准的创建，启动后对此属性所做的调整将不会生效。这样可以避免指标数据丢失，也可以优化指标收集。 默认值 100 默认属性 hystrix.command.default.metrics.rollingPercentile.bucketSize 实例属性 hystrix.command.HystrixCommandKey.metrics.rollingPercentile.bucketSize 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsRollingPercentileBucketSize(int value) metrics.healthSnapshot.intervalInMilliseconds此属性设置允许执行运行成功和错误百分比并影响断路器状态的健康快照之间等待的时间（以毫秒为单位）。 在大容量的电路上，连续计算误差百分比可能会成为CPU密集型的，因此这个属性允许你控制计算的频率。 默认值 500 默认属性 hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 实例属性 hystrix.command.HystrixCommandKey.metrics.healthSnapshot.intervalInMilliseconds 如何设置默认实例 HystrixCommandProperties.Setter().withMetricsHealthSnapshotIntervalInMilliseconds(int value) 请求上下文（Request Context）这些属性涉及HystrixCommand使用HystrixRequestContext功能。 requestCache.enabled此属性指示HystrixCommand.getCacheKey())是否应与HystrixRequestCache一起使用，以通过请求范围缓存提供重复数据删除功能。 默认值 true 默认属性 hystrix.command.default.requestCache.enabled 实例属性 hystrix.command.HystrixCommandKey.requestCache.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withRequestCacheEnabled(boolean value) requestLog.enabled此属性指示是否应将HystrixCommand执行和事件记录到HystrixRequestLog 默认值 true 默认属性 hystrix.command.default.requestLog.enabled 实例属性 hystrix.command.HystrixCommandKey.requestLog.enabled 如何设置默认实例 HystrixCommandProperties.Setter().withRequestLogEnabled(boolean value) 破裂器属性（Collapser Properties）以下属性控制HystrixCollapser行为。 maxRequestsInBatch此属性设置批处理允许的最大请求数量，然后触发批处理执行。 默认值 Integer.MAX_VALUE 默认属性 hystrix.collapser.default.maxRequestsInBatch 实例属性 hystrix.collapser.HystrixCollapserKey.maxRequestsInBatch 如何设置默认实例 HystrixCollapserProperties.Setter().withMaxRequestsInBatch(int value) timerDelayInMilliseconds此属性设置触发执行之后创建批处理的毫秒数。 默认值 10 默认属性 hystrix.collapser.default.timerDelayInMilliseconds 实例属性 hystrix.collapser.HystrixCollapserKey.timerDelayInMilliseconds 如何设置默认实例 HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(int value) requestCache.enabled此属性指示是否为HystrixCollapser.execute()和HystrixCollapser.queue()调用启用了请求缓存。 默认值 true 默认属性 hystrix.collapser.default.requestCache.enabled 实例属性 hystrix.collapser.HystrixCommandKey.requestCache.enabled 如何设置默认实例 HystrixCollapserProperties.Setter().withRequestCacheEnabled(boolean value) 线程池属性（Thread Pool Properties）以下属性控制Hystrix命令执行的线程池的行为。请注意，这些名称与ThreadPoolExecutor Javadoc中的名称相匹配 大多数情况下，10个线程的默认值都可以（通常可以做得更小）。 要确定是否需要更大，计算大小的基本公式是： 在健康时每秒的请求高峰数 × 99%的延迟秒数+一些喘息的空间时。 看下面的例子，看看这个公式是如何实施的。 总体原则是尽可能保持池的小，因为它是减轻负载并防止资源在延迟发生时被阻塞的主要工具。 Netflix API有30+的线程池被设置为10，两个在20，一个在25。 上图显示了一个配置示例，其中依赖关系没有理由达到第99.5百分位，因此它在网络超时层将其缩短，并立即重试，并期望大部分时间会得到中位延迟能够在300ms线程超时内完成这一切。 如果依赖有合法的理由有时达到99.5％（比如缓存未命中），那么网络超时将被设置得比它高，比如325ms，重试0或1次，线程超时设置更高（350ms + ）。 线程池的大小为10，以处理第99个百分点请求的突发，但是当一切正常时，此线程池通常在任何给定时间通常只有1或2个线程处于活动状态，以服务大多数40ms的中间调用。 当你正确地配置它时，HystrixCommand层的超时应该是很少的，但是如果网络等待时间以外的事情影响了时间，或者在最坏的情况下连接+读+重试+连接+读超过配置的整体超时。 每个方向的配置和折衷的攻击性对于每个依赖性是不同的。 当性能特征发生变化或发现问题时，您可以根据需要实时更改配置，而且如果出现问题或配置错误，则无需关闭整个应用程序。 coreSize此属性设置核心线程数。 默认值 10 默认属性 hystrix.threadpool.default.coreSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.coreSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withCoreSize(int value) maximumSize在1.5.9中添加。该属性设置最大的线程池大小。这是开始无需拒绝HystrixCommand即可支持的最大并发数量。请注意，如果您还设置了allowMaximumSizeToDivergeFromCoreSize，则此设置才会生效。在1.5.9之前，核心和最大大小总是相等的。 默认值 10 默认属性 hystrix.threadpool.default.maximumSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.maximumSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMaximumSize(int value) maxQueueSize该属性设置BlockingQueue实现的最大队列大小。 如果将其设置为-1，则将使用SynchronousQueue，其它正值将使用LinkedBlockingQueue。 注意： 这个属性只适用于初始化时间，因为如果不重新初始化线程执行器，不支持的队列被调整或改变。 如果您需要越过此限制并允许在队列中进行动态更改，请参阅queueSizeRejectionThreshold属性。 要在SynchronousQueue和LinkedBlockingQueue之间切换，需要重新启动。 默认值 -1 默认属性 hystrix.threadpool.default.maxQueueSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.maxQueueSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMaxQueueSize(int value) queueSizeRejectionThreshold此属性设置队列大小拒绝阈值 —— 即使maxQueueSize尚未达到，拒绝将发生的人为最大队列大小。此属性的存在是因为BlockingQueue的maxQueueSize不能动态更改，我们希望允许您动态更改影响拒绝的队列大小。 当排队一个线程执行时，HystrixCommand使用它。 注意： 如果maxQueueSize == -1，则此属性不适用。 默认值 5 默认属性 hystrix.threadpool.default.queueSizeRejectionThreshold 实例属性 hystrix.threadpool.HystrixThreadPoolKey.queueSizeRejectionThreshold 如何设置默认实例 HystrixThreadPoolProperties.Setter().withQueueSizeRejectionThreshold(int value) keepAliveTimeMinutes该属性设置保持活动时间，以分钟为单位。 在1.5.9之前，所有线程池都是固定大小的，如coreSize == maximumSize。在1.5.9之后，将allowMaximumSizeToDivergeFromCoreSize设置为true允许这两个值发散，以便线程池可以获取/释放线程。如果coreSize &lt;maximumSize，那么这个属性控制一个线程在被释放之前将不被使用的时间。 默认值 1 默认属性 hystrix.threadpool.default.keepAliveTimeMinutes 实例属性 hystrix.threadpool.HystrixThreadPoolKey.keepAliveTimeMinutes 如何设置默认实例 HystrixThreadPoolProperties.Setter().withKeepAliveTimeMinutes(int value) allowMaximumSizeToDivergeFromCoreSize在1.5.9中添加。此属性允许maximumSize的配置生效。该值可以等于或高于coreSize。设置coreSize &lt;maximumSize会创建一个线程池，它可以支持maximumSize并发性，但是会在相对不活动的时间内将线程返回给系统。 （以keepAliveTimeInMinutes为准） 默认值 false 默认属性 hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize 实例属性 hystrix.threadpool.HystrixThreadPoolKey.allowMaximumSizeToDivergeFromCoreSize 如何设置默认实例 HystrixThreadPoolProperties.Setter().withAllowMaximumSizeToDivergeFromCoreSize(boolean value) metrics.rollingStats.timeInMilliseconds该属性设置统计滚动窗口的持续时间，以毫秒为单位。这是为线程池保留多长时间的指标。 窗口根据这些增量被分成桶和“卷”。 默认值 10000 默认属性 hystrix.threadpool.default..metrics.rollingStats.timeInMilliseconds 实例属性 hystrix.threadpool.HystrixThreadPoolKey.metrics.rollingStats.timeInMilliseconds 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMetricsRollingStatisticalWindowInMilliseconds(int value) metrics.rollingStats.numBuckets该属性设置滚动统计窗口分成的桶的数量。 注意： 必须要确保如下条件：“metrics.rollingStats.timeInMilliseconds ％ metrics.rollingStats.numBuckets == 0” ，否则会引发异常。 换句话说，10000/10是可以的，10000/20也可以，但是10000/7不行。 默认值 10 取值范围 能被metrics.rollingStats.timeInMilliseconds整除的任何值，结果应该是数百或数千毫秒的桶。大容量的性能还没有测试过小于100ms的桶。 默认属性 hystrix.threadpool.default.metrics.rollingStats.numBuckets 实例属性 hystrix.threadpool.HystrixThreadPoolKey.metrics.rollingStats.numBuckets 如何设置默认实例 HystrixThreadPoolProperties.Setter().withMetricsRollingStatisticalWindowBuckets(int value) 参考资料https://github.com/Netflix/Hystrix/wiki/Configuration table th:first-of-type{width:80px}]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hystrix</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS下基于Python2.7安装OpenCV3]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FMacOs-install-opencv.html</url>
    <content type="text"><![CDATA[步骤概览安装Xcode以及Apple Command Line Tools安装Homebrew创建Python虚拟环境安装NumPy安装OpenCV安装Xcode以及Apple Command Line Tools从App Store下载并安装Xcode。接受Apple开发者协议。1sudo xcodebuild -license 安装Apple Command Line Tools 1sudo xcode-select --install 输入上面的命令后，会弹出一个窗口，确认你想要安装命令行工具，点击install或安装按钮进行安装。 安装HomebrewHomebrew是MacOS的包管理器，类似于Ubuntu的apt-get。 安装命令： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 一旦安装了Homebrew，您应该对其进行更新，以确保下载最新的软件包定义： 1brew update 修改环境变量文件，如果你用的是bash请球盖vi ~/.bash_profile，如果你用的是zsh请修改vi ~/.zshrc，添加如下内容到对应的文件： 12# Homebrewexport PATH=/usr/local/bin:$PATH 使用source命名来让配置生效：source ~/.bash_profile 或 source ~/.zshrc。 创建Python虚拟环境 MacOS默认已安装Python，不同的MacOS版本可能对应的Python版本不同。可以使用python --version来获取当前系统中的Python版本。如果当前版本不是2.7.x，可以使用Homebrew来安装： 1brew install python 安装完成之后，我们需要把操作系统的python链接到Homebrew的安装目录： 1brew linkapps python 检查安装是否正确： 1which python 如果输出的路径是/usr/local/bin/python则说明安装Python成功。 安装虚拟环境 由于在OS X El Capitan中，在内核下引入了Rootless机制，即使root用户也无法对/System、/bin、/sbin、/usr(except /usr/local)目录有写和执行权限，只有Apple以及Apple授权签名的软件（包括命令行工具）可以修改此目录。 因此在使用操作系统自带的Python时，使用pip安装某些包时会存在失败的情况。所以我们在这里使用python虚拟环境来规避这个问题。 1pip install virtualenv virtualenvwrapper 安装完成之后，我们需要再次修改环境变量文件，如果你用的是bash请球盖vi ~/.bash_profile，如果你用的是zsh请修改vi ~/.zshrc，添加如下内容到对应的文件： 12# Virtualenv/VirtualenvWrappersource /usr/local/bin/virtualenvwrapper.sh 使用source命名来让配置生效：source ~/.bash_profile 或 source ~/.zshrc。 创建虚拟环境 1mkvirtualenv opencv 上面命名创建了一个名叫opencv的虚拟环境，你可以使用workon opencv进入虚拟环境，也可以使用deactivate指令从虚拟环境中退出。 安装NumPy 进入虚拟环境: workon opencv pip install numpy 安装OpenCV 环境准备： 123brew install cmake pkg-configbrew install jpeg libpng libtiff openexrbrew install eigen tbb 从github下载OpenCV3 123cd ~git clone https://github.com/opencv/opencvgit clone https://github.com/opencv/opencv_contrib 下载完成之后，进入源码目录切换到指定的版本，譬如安装OpenCV的3.3.1版本： 1234cd ~/opencvgit checkout -b 3.3.1 3.3.1cd ~/opencv_contribgit checkout -b 3.3.1 3.3.1 配置CMake 123cd ~/opencvmkdir buildcd build 接着我们就可以执行cmake命令了，但在执行命令之前有两个参数需要调整： 1234567891011cmake -D CMAKE_BUILD_TYPE=RELEASE \-D CMAKE_INSTALL_PREFIX=/usr/local \-D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib/modules \-D PYTHON2_LIBRARY=YYY \-D PYTHON2_INCLUDE_DIR=ZZZ \-D PYTHON2_EXECUTABLE=/usr/local/bin/python \-D BUILD_opencv_python2=ON \-D BUILD_opencv_python3=OFF \-D INSTALL_PYTHON_EXAMPLES=ON \-D INSTALL_C_EXAMPLES=OFF \-D BUILD_EXAMPLES=ON .. cmake重要参数解释： BUILD_opencv_python2=ON：这表明我们要基于Python2.7来安装OpenCV 3； BUILD_opencv_python3=OFF：这表明我们关闭Python3； PYTHON2_LIBRARY=YYY：这是你自己填写的第一个值。您将需要用您的libpython2.7.dylib文件的路径替换YYY（我将帮助您在下一节中找到它）； PYTHON2_INCLUDE_DIR=ZZZ：这是您需要填写的第二个值。您需要将ZZZ替换为Python.h头文件所在目录的路径（同样，我将帮助您确定此路径） 获取PYTHON2_LIBRARY的路径 1ls /usr/local/Cellar/python/2.7.*/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config/libpython2.7.dylib 将上面的输出拷贝出来替换掉PYTHON2_LIBRARY=YYY中的YYY。 获取PYTHON2_INCLUDE_DIR的路径 1ls -d /usr/local/Cellar/python/2.7.*/Frameworks/Python.framework/Versions/2.7/include/python2.7/ 将上面的输出拷贝出来替换掉PYTHON2_INCLUDE_DIR=ZZZ中的ZZZ。 替换完成之后即可执行。 编译与安装 1make -j4 -j开关控制并发编译OpenCV的处理器数量，因为我在四核系统上，所以我用-j4。编译可能需要几十分钟左右。 如果编译没有出错就可以进行安装了 1sudo make install 安装成功后，可以在/usr/local/lib/python2.7/site-packges/下找到cv2.so文件。 在虚拟环境中添加cv2.so的软连接 12cd ~/.virtualenvs/cv/lib/python2.7/site-packages/ln -s /usr/local/lib/python2.7/site-packages/cv2.so cv2.so cv2.so 测试与验证OpenCV 打开一个新的终端： 123456789$ workon opencv$ pythonPython 2.7.12 (default, Oct 11 2016, 05:20:59) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import cv2&gt;&gt;&gt; cv2.__version__'3.3.1&gt;&gt;&gt; 如何完整的卸载OpenCV? 可以通过进入之前的build目录，执行make uninstall来完整卸载OpenCV. 参考资料 MacOS基于Python2.7安装OpenCV3 MacOS基于Python3.5安装OpenCV3]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geetest拖拽验证码破解思路（java）]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FGeetest-Crack.html</url>
    <content type="text"><![CDATA[项目中有个需求希望能获取公司的工商注册信息，刚开始是想与第三方数据公司合作，因种 种原因合作没有达成。于是想做个爬虫直接从工商局的《企业信用信息公示系统》中获取。 要想从《企业信用信息公示系统》中爬取数据，首先必须解决掉Geetest验证码的问题。 经过一系列的摸索，发现要想破解geetest的验证码，主要需要解决如下几个问题：背景图的还原找到背景图中缺口的位置将滑块拖拽到缺口背景图的还原Geetest背景图分为两张，一张是完整背景图，一张是带缺口的背景图。每张图片被分成 52 份， 上下两部分各 26 份，然后乱序排列。在网页上显示时，是通过css来将乱序的 碎片重新组列成完整的图片。乱序图片：正常图片：因此，我们必须将原始的背景乱序图片切根据页面上的css样式将图片切割成 52 份，并 按照先后顺序拼接还原成正确的图片。需要使用到java.awt.image.BufferedImage类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 将Geetest打乱的图片还原，Geetest的原始背景图是分成52份碎片乱序组合的。目前是上下各26份，每份碎片图片宽10px， 高58px。 * * @param image 原始背景图 * @param locations 展示位置列表，数据结构：[&#123;x=-25, y=-58&#125;, ...] * @return 顺序排列好的图片 */public static BufferedImage recover(BufferedImage image, List&lt;Map&lt;String, Integer&gt;&gt; locations) throws IOException &#123; long begin = System.currentTimeMillis(); int per_image_with = 10; // 每张碎片图片的宽度 int per_image_height = 58; // 每张碎片图片的高度 List&lt;BufferedImage&gt; upperList = new ArrayList&lt;&gt;(); List&lt;BufferedImage&gt; downList = new ArrayList&lt;&gt;(); // 将原始图片裁剪成碎片 for (Map&lt;String, Integer&gt; location : locations) &#123; int x = location.get("x"); int y = location.get("y"); if (y == -58) &#123; upperList.add(image.getSubimage(abs(x), 58, per_image_with, per_image_height)); &#125; else if (y == 0) &#123; downList.add(image.getSubimage(abs(x), 0, per_image_with, per_image_height)); &#125; &#125; BufferedImage newImage = new BufferedImage(upperList.size() * per_image_with, image.getHeight(), image.getType()); // 重绘图片的上半部分 int x_offset = 0; for (BufferedImage bufferedImage : upperList) &#123; Graphics graphics = newImage.getGraphics(); graphics.drawImage(bufferedImage, x_offset, 0, null); x_offset += bufferedImage.getWidth(); &#125; // 重绘图片的下半部分 x_offset = 0; for (BufferedImage bufferedImage : downList) &#123; Graphics graphics = newImage.getGraphics(); graphics.drawImage(bufferedImage, x_offset, 58, null); x_offset += bufferedImage.getWidth(); &#125; log.debug("还原图片耗时：&#123;&#125;ms", System.currentTimeMillis() - begin); return newImage;&#125; 找到背景图中缺口的位置 正常图片： 缺口图片： Geetest验证时，只需要将拼图块水平移动到正确的位置即可。因此通过上面两张图片比 对，发现我们只要找到缺口的x坐标即可。 这里我借用的参考内容的方法：两张原始图的大小都是相同的 260*116，那就通过两个 for 循环依次对比每个像素点的 RGB 值，如果相差超过 50 则就认为找到了缺口的位置。 12345678910111213141516171819202122232425262728293031323334353637/** * 计算验证图的缺口位置（x轴） 两张原始图的大小都是相同的260*116，那就通过两个for循环依次对比每个像素点的RGB值， 如果RGB三元素中有一个相差超过50则就认为找到了缺口的位置 * * @param image1 图像1 * @param image2 图像2 * @return 缺口的x坐标 */public static int getDiffX(BufferedImage image1, BufferedImage image2) &#123; long begin = System.currentTimeMillis(); for (int x = 0; x &lt; image1.getWidth(); x++) &#123; for (int y = 0; y &lt; image1.getHeight(); y++) &#123; if (!isSimilar(image1, image2, x, y)) &#123; return x; &#125; &#125; &#125; log.debug("图片对比耗时：&#123;&#125;ms", System.currentTimeMillis() - begin); return 0;&#125;/** * 判断image1, image2的[x, y]这一像素是否相似，如果该像素的RGB值相差都在50以内，则认为相似。 * * @param image1 图像1 * @param image2 图像2 * @param x_offset x坐标 * @param y_offset y坐标 * @return 是否相似 */public static boolean isSimilar(BufferedImage image1, BufferedImage image2, int x_offset, int y_offset) &#123; Color pixel1 = new Color(image1.getRGB(x_offset, y_offset)); Color pixel2 = new Color(image2.getRGB(x_offset, y_offset)); return abs(pixel1.getBlue() - pixel2.getBlue()) &lt; 50 &amp;&amp; abs(pixel1.getGreen() - pixel2.getGreen()) &lt; 50 &amp;&amp; abs(pixel1.getRed() - pixel2.getRed()) &lt; 50;&#125; 将滑块拖拽到缺口Geetest在拖拽拼图块时，对拼图块的移动轨迹做了一些 “ 人工智能 ” 的算法识别，使 用程序直接将拼图块拖入缺口时，发现有很大的概率会被识别为机器操作，页面显示怪物 吃掉了饼图。因此我们需要采用一些算法来模拟人拖拽的行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/** * 根据缺口位置x_offset，仿照手动拖动滑块时的移动轨迹。 * 手动拖动滑块有几个特点： * 开始时拖动速度快，最后接近目标时会慢下来； * 总时间大概1~3秒； * 有可能会拖超过后再拖回头； * * @return 返回一个轨迹数组，数组中的每个轨迹都是[x,y,z]三元素：x代表横向位移，y代表竖向位移，z代表时间间隔，单位毫秒 */private static List&lt;Map&lt;String, Integer&gt;&gt; getTrack(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks; long begin = System.currentTimeMillis(); // 实际上滑块的起始位置并不是在图像的最左边，而是大概有6个像素的距离，所以滑动距离要减掉这个长度 x_offset = x_offset - 6; if (getRandom(0, 10) % 2 == 0) &#123; tracks = strategics_1(x_offset); &#125; else &#123; tracks = strategics_2(x_offset); &#125; log.debug("生成轨迹耗时: &#123;&#125;ms", System.currentTimeMillis() - begin); log.debug("计算出移动轨迹: &#123;&#125;", tracks); return tracks;&#125;/** * 轨迹策略1 */private static List&lt;Map&lt;String, Integer&gt;&gt; strategics_1(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks = new ArrayList&lt;&gt;(); float totalTime = 0; int x = getRandom(1, 3); // 随机按1~3的步长生成各个点 while (x_offset - x &gt;= 5) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", x); point.put("y", 0); point.put("z", 0); tracks.add(point); x_offset = x_offset - x; x = getRandom(1, 5); totalTime += point.get("z").floatValue(); &#125; // 后面几个点放慢时间 for (int i = 0; i &lt; x_offset; i++) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", 1); point.put("y", 0); point.put("z", getRandom(10, 200)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; log.debug("预计拖拽耗时: &#123;&#125;ms", totalTime); return tracks;&#125;/** * 轨迹策略2 */private static List&lt;Map&lt;String, Integer&gt;&gt; strategics_2(int x_offset) &#123; List&lt;Map&lt;String, Integer&gt;&gt; tracks = new ArrayList&lt;&gt;(); float totalTime = 0; int dragX = 0; // 已拖拽的横向偏移量 int nearRange = getRandom(5, 10); // 靠近缺口的范围 while (dragX &lt; x_offset - nearRange) &#123; // 生成快速拖拽点，拖拽距离非常靠近切口 int stepLength = getRandom(1, 5); // 随机按1~5的步长生成各个点 Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", stepLength); point.put("y", 0); point.put("z", getRandom(0, 2)); tracks.add(point); totalTime += point.get("z").floatValue(); dragX += stepLength; &#125; // 随机一定的比例将滑块拖拽过头 if (getRandom(0, 99) % 2 == 0) &#123; int stepLength = getRandom(10, 15); // 随机按1~5的步长生成各个点 Map&lt;String, Integer&gt; attachPoint = new HashMap&lt;&gt;(3); attachPoint.put("x", stepLength); attachPoint.put("y", 0); attachPoint.put("z", getRandom(0, 2)); tracks.add(attachPoint); dragX += stepLength; totalTime += attachPoint.get("z").floatValue(); &#125; // 精确点 for (int i = 0; i &lt; Math.abs(dragX - x_offset); i++) &#123; if (dragX &gt; x_offset) &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", -1); point.put("y", 0); point.put("z", getRandom(10, 100)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; else &#123; Map&lt;String, Integer&gt; point = new HashMap&lt;&gt;(3); point.put("x", 1); point.put("y", 0); point.put("z", getRandom(10, 100)); tracks.add(point); totalTime += point.get("z").floatValue(); &#125; &#125; log.debug("预计拖拽耗时: &#123;&#125;ms", totalTime); return tracks;&#125;/** * 根据移动轨迹，模拟拖动极验的验证滑块 */private static boolean simulateDrag(WebDriver webDriver, Site site, List&lt;Map&lt;String, Integer&gt;&gt; tracks) throws InterruptedException &#123; log.debug("开始模拟拖动滑块"); WebElement slider = webDriver.findElement(By.cssSelector(site.getGeetest().getSliderKnob())); log.debug("滑块初始位置: &#123;&#125;", slider.getLocation()); Actions actions = new Actions(webDriver); actions.clickAndHold(slider).perform(); for (Map&lt;String, Integer&gt; point : tracks) &#123; int x = point.get("x") + 22; int y = point.get("y") + 22; actions.moveToElement(slider, x, y).perform(); int z = point.get("z"); TimeUnit.MILLISECONDS.sleep(z); &#125; TimeUnit.MILLISECONDS.sleep(getRandom(100, 200)); // 随机停顿100~200毫秒 actions.release(slider).perform(); TimeUnit.MILLISECONDS.sleep(100); // 等待0.1秒后检查结果 try &#123; // 在5秒之内检查弹出框是否消失，如果消失则说明校验通过；如果没有消失说明校验失败。 new WebDriverWait(webDriver, 5).until((ExpectedCondition&lt;Boolean&gt;) driver -&gt; &#123; try &#123; WebElement popupElement = driver.findElement(By.cssSelector(site.getGeetest().getPopupWrap())); return !popupElement.isDisplayed(); &#125; catch (NoSuchElementException e) &#123; return true; // 元素不存在也返回true &#125; &#125;); return true; &#125; catch (Exception e) &#123; return false; &#125;&#125; 总结解决好上面的三点之后，Geetest验证基本就破解掉了，但是要爬取企业信用信息公示系统中的数据还有一些事情要做。目前工商局有多个地区系统，每个系统的页面解析处理也不一样。某些地区系统甚至还针对访问频次做了控制，你可以通过 IP 代理来解决。 完整的代码示例请参考: https://github.com/aqlu/geetest-crack 运行效果： 本文的参考资料：http://blog.csdn.net/paololiu/article/details/52514504]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>geetest</tag>
        <tag>验证码破解</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS科学上网]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2FMacOs-scientific-Surf-the-Internet.html</url>
    <content type="text"><![CDATA[本文将介绍如何在MacOS上采用VMess协议与墙外VPS通信，其中主要用到了[v2ray]这款开源工具。服务端安装(Centos)因为我选择的VPS的Centos的操作系统，所以此章节主要基于Centos操作系统来描述。安装包下载：wget https://github.com/v2ray/v2ray-core/releases/download/v2.40/v2ray-linux-64.zip解压安装包到/opt目录：unzip v2ray-linux-64.zip -d /opt编写配置文件:12cd /opt/v2ray-v2.40-linux-64vi config.json config.json内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "log" : &#123; // 日志输出配置 "access": "/var/log/v2ray/access.log", "error": "/var/log/v2ray/error.log", "loglevel": "warning" &#125;, // 对外提供 vmess 协议 "inbound": &#123; "port": 28399, // 监听端口 "protocol": "vmess", "settings": &#123; "clients": [&#123; "id": "3b129ddd-72a3-4d28-aeee-028a0fe86e33", // 可以随机生成一个，但必须保证服务端ID与客户端ID必须保持一致 "level": 1, "alterId": 64, "security": "aes-128-gcm" &#125;] &#125; &#125;, "outbound": &#123; "protocol": "freedom", "settings": &#123;&#125; &#125;, "routing": &#123; "strategy": "rules", "settings": &#123; "rules": [&#123; "type": "field", "ip": [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "::1/128", "fc00::/7", "fe80::/10" ], "outboundTag": "blocked" &#125;] &#125; &#125;&#125; 启动v2ray服务：/opt/v2ray-v2.40-linux-64/v2ray -config=/opt/v2ray-v2.40-linux-64/config.json &gt; v2ray.log &amp; 客户端安装(MacOs) 安装包下载：wget https://github.com/v2ray/v2ray-core/releases/download/v2.40/v2ray-macos.zip 解压安装包到/usr/local/opt目录：unzip v2ray-linux-64.zip -d /usr/local/opt 编写配置文件: 12cd /usr/local/opt/v2ray-v2.40-linux-64vi config.json config.json内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; "log" : &#123; "access": "/var/log/v2ray/access.log", "error": "/var/log/v2ray/error.log", "loglevel": "warning" &#125;, // 对外提供 socks5 协议 "inbound": &#123; "port": 1080, // 监听端口 "protocol": "socks", // 入口协议为 SOCKS 5 "settings": &#123; "auth": "noauth" //socks的认证设置，noauth 代表不认证，由于 socks 通常在客户端使用，所以这里不认证 &#125; &#125;, "outbound": &#123; "protocol": "vmess", // 出口协议，对应服务端的入口协议 "settings": &#123; "vnext": [&#123; "address": "serveraddr.com", // 服务器地址，请修改为你自己的服务器 ip 或域名 "port": 28399, // 服务器端口，对应服务器端入口的端口 "users": [&#123; "id": "3b129ddd-72a3-4d28-aeee-028a0fe86e33", // 用户ID, 服务端ID与客户端ID必须保持一致 "alterId": 64 // 此处的值也应当与服务器相同 &#125;] &#125;] &#125; &#125;, "routing": &#123; "strategy": "rules", "settings": &#123; "rules": [&#123; "type": "field", "ip": [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "::1/128", "fc00::/7", "fe80::/10" ], "outboundTag": "blocked" &#125;] &#125; &#125;&#125; 启动v2ray服务：/usr/local/opt/v2ray-v2.40-linux-64/v2ray -config=/usr/local/opt/v2ray-v2.40-linux-64/config.json &gt; v2ray.log &amp; 客户端安装的另一种方式（基于Docker安装） 下载镜像： docker pull v2ray/official 编写配置文件： 123mkdir -p ~/v2raycd ~/v2rayvi config.json # 内容请参考客户端安装(MacOs) 创建容器： 1docker run -d --restart=always --name v2ray -v ~/v2ray:/etc/v2ray -p 1080:1080 v2ray/official v2ray -config=/etc/v2ray/config.json -p 后面跟的端口为config.json中inbound配置的监听端口 校验容器是否创建成功：docker container ls 启动容器：docker start 停止v2ray：docker stop v2ray 重启v2ray：docker restart v2ray 查看日志：docker container log v2ray 更多参考资料 项目：https://github.com/v2ray/v2ray-core 用户手册：https://www.v2ray.com/ 其它文档：https://toutyrater.github.io/]]></content>
      <categories>
        <category>技术笔记</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>vmess</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F%2Fhello-world.html</url>
    <content type="text"><![CDATA[Hello World!这是我的第一篇博客，感谢Hexo提供了一个简单好用的博客框架，感谢NexT优雅的的主题。此博客是本人的一个杂记。为什么叫杂记？其实就是一些乱七八糟的东西，可能是曾经的一些技术笔记，也可能是一些技术专题的连载，也可能是一些生活观点与琐事。]]></content>
  </entry>
</search>
